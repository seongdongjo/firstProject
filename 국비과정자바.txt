package day02;

public class Ex01 {

	public static void main(String[] args) {
		//자바의 자료형
		//1)primitive, 원시 자료형(객체지향 언어인데 객체가 아닌 형태)
		// - boolean(1byte), byte, short(2byte), char(2byte), int, float(4byte), long, double
		
		//클래스의 첫글자는 대문자로 작성
		
		//프로젝트, 패키지, 변수이름, 함수이름 등의 첫글자는 소문자로작성
		//단, 클래스의 static final 요소는 모두 대문자로 작성한다.(단어간 구문은 _로 한다)
		
		//byte = 8비트 256 -> 127 ~ -128(총 256개)
		//short = 16비트 -> -32768 ~ +32767
		//int = 약 +-21억
		float f1 = 1.2f; //f가 없으면 double로 처리함
		long ln = 1000000000L; //L이 없으면 int로 처리함
		
		char ch2; //지정한 자료형의 크기만큼 새로운 공간을 할당받는다.
		ch2 = '가'; //할당 받은 공간에 새로운 값을 저장, 기존의 값은 사라진다.
		
		
		//2) reference type, 참조 자료형(실제 데이터가 존재하는 메모리의 주소를 저장하여 참조)
		// - 클래스
		// - 배열
		
		//즉, 원시자료형과 참조자료형의 차이는
		//원시자료형은 값을 직접 메모리 공간에 넣어서 이름을 정해서 쓰는것
		//참조자료형은 메모리의 주소를 참조하는것이다.
		
		// String name = "이지은"
		// name(0x100)에는 이지은을 가리키는 메모리주소가 들어가있다(시작주소).
		// 그래서 name ="james"를하면 실제 데이터인 "이지은"이 바뀌는게 아니다.
		// 새로운공간을 만들어서 james를 만들고 name은 새로운 메모리주소를 받는다.
		
		byte a = 10;
		int num = a; //옮겨담아도 문제가 생기지 않는다. 자동,암묵적형변환
		
		//Casting(강제 형변환,명시적)
		int b = 10;
		byte c = (byte)b; //단, 값이 잘린다.
		
		}
}
========================================================================================
package day02;

public class Ex02 {

	public static void main(String[] args) {
		byte by = 10;
		short sh = 20;
		char ch = 65;
		int num = 30;
		long lo = 40L;
		float fl = 3.14F;
		double db = 11.56;
		
		int a = by; //promotion(자동)
		char b = (char)db; //casting(강제)
		long c = sh; //promotion
		float d = num; //promotion 실수로표현됨
		short e = (short)ch; //casting(두자료형의 크기는 같으나, 표현범위가 달라서 데이터가 잘릴수있다)
		double f = by; //promotion
		
		//즉, 표현범위가 다르기때문에 잘릴위험이 존재한다. 그러면 casting이다.
		//short -32768 +32767
		//char  0 ~ 65535 
	}
}
=============================================================================================
package day02;

public class Ex03 {
	//Wrapper class
	//primitive 자료형을 대체하기 위한 클래스
	//클래스 자료형이므로 참조변수의 크기는 고정적으로 4byte다(메모리 주소는 4byte int)
	
	public static void main(String[] args) {
		//primitive type들
		boolean bo1 = true;
		byte by1 = 10;
		short sh1 = 32;
		char ch1 = 'A';
		int num1 = 1234;
		long ln1 = 100L;
		float fl1 = 1.2f;
		double db1 = 12.56;
		
		
		//대부분의 Wrapper class는 primitive type에서 첫글자를 대문자로
		//비객체형태를 객체형태로 저장한다. -> wrapper class
		//전부다 4byte이다.
		//bo2. 을 통해 여러 함수를 호출할 수 있다.
		Boolean bo2 = bo1;
		Byte by2 = by1;
		Short sh2 = sh1;
		Character ch2 = ch1;
		Integer num2 = num1;
		Long ln2 = ln1;
		Float fl2 = fl1;
		Double db2 = db1;
		
		//문자열로 바꿔주는 toString기능
		String bo3 = bo2.toString();
		System.out.println(bo3.length());
		
		//특징
		//1) wrapper class는 각 primitive에 대해서 1:1로 대응
		//2) primitive 간에는 어느정도 형변환이 허용되지만, wrapper class끼리는 형변환을 지원xx
		int n1 = by1; //문제가 없다
		// Integer n2 = by2;  wrapper끼리 형변환 에러난다.
		Integer n3 = n1; //primitive와 wrapper 문제가 없다.
		
		//두가지방법
		Integer n2 =by2.intValue(); //메서드로 바로변환(wrapper인 by2를 int로 변환)
		Integer n4 =(int)(byte)by2; //Byte -> byte -> int -> Integer
		
		//wrapper class는 아니다. String이
		//String, 문자열을 저장하는 클래스 타입 자료형
		//str1,str2 의 크기는 값다.(메모리 주소만 가지고있기 때문에)
		String str1 = new String("문자열 내용");
		String str2 = "안녕하세요";
		
		System.out.println(str2.length()); //글자갯수
		
		//문자열은 쌍따옴표(String), 단일 문자는 홑따옴표로 묶는다.(char)
		
	}
}
===============================================================================
package day02;

public class Quiz02 {
	public static void main(String[] args) {
		String name = new String("조성동");
		Integer age = 13;
		//Double db = 0; 에러난다. 
		Double db2 = (double)0;
		Double db = 0.0;
		db = 3.14;
		
		//wrapper끼리 형변환이 안되기때문에 아래처럼 작성
		Float ft = db.floatValue(); //Double(db를) -> ->float -> Float 
		//또는
		Float ft1 =(float)(double)db;
	}
}
==================================================================================
package io;

public class Ex01 {

	public static void main(String[] args) {
		String name = "이지은";
		int age = 29;
		System.out.println(name + "님은" + age + "살 입니다");
		System.out.println(1 + "1"); //11 (문자열로 통합)
		
		System.out.println(name + "님은 만" + (age - 1) + "살 입니다");
		
		//printf는 java 1.5이상에서만 쓸 수 있다.
		
		// %s : String, 자바에서는 다른 자료형의 값도 대부분 처리 가능
		// %d : 10진수
		// %f : 실수, double이던 float이던 사용가능
		
		// \n : 줄바꿈문자, new line, line feed, ASCII Code 10번
		// \r : 커서를 줄 가장 왼쪽으로, carriage return, ASCII Code 13
		// %% : %글자를 출력하기 위해서 사용

		System.out.printf("%s님\n",name);
		System.out.printf("%20s\n","blackpink");
		
		//2칸 확보 후, 빈칸은 0으로 채우기[02 : 15]
		System.out.printf("\t[%02d : %02d]\n", 2, 15);
		
		double pi = 3.141592;
		System.out.printf("pi: %.2f\n", pi);
		
		char ch ='가';
		System.out.printf("ch: %c, ch: %d\n", ch, (int)ch);	 //int로 변환
	
		String format = "%s님은 %d살입니다\n";
		String msg = String.format(format, name,age);
	}
}
===========================================================================
package input;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Ex01 {
	public static void main(String[] args) throws Exception {	// 모든 예외를 상위 레벨로 전가한다
		
		System.out.println(System.in);		// 표준 시스템 입력
		System.out.println(System.out);		// 표준 시스템 출력
		System.out.println(System.err);		// 에러 시스템 출력
		
//		사용자에게 입력을 받는 행위는 여러가지 예외 상황이 발생할 수 있는 가능성을 가지고 있다
		
		System.out.print("글자 하나 입력 : ");
		int n1 = System.in.read();			// 입력받은 글자의 정수코드값을 반환하는 함수 (1byte)
		System.out.println("n1 : " + n1);
		System.in.read();
		System.in.read();
		
		System.out.print("한글 하나 입력 : ");
		InputStreamReader is = new InputStreamReader(System.in);
		// InputStreamReader : 2바이트 크기의 데이터를 읽을 수 있는 객체
		int n2 = is.read();
		System.out.println("n2 : " + n2);
		
		BufferedReader br = new BufferedReader(is); //is를 담고
		// BufferedReader : 버퍼에 담긴 내용에서 원하는 만큼 골라서 입력받을 수 있는 객체
		// 버퍼 : 데이터의 입력 대기 공간
		br.readLine(); 		// 기존 버퍼에 남아있던 값을 가져와서 버림
		
		System.out.print("한글 하나 입력 : ");
		int n3 = br.read();
		System.out.println("n3 : " + n3);
		br.readLine(); 		// 기존 버퍼에 남아있던 값을 가져와서 버림
		
		System.out.print("문장을 입력하세요 : ");
		String str = br.readLine();
		System.out.println("str : " + str);
		
	}
}

=====================================================================================
package input;

import java.util.Scanner;	// java 1.5 ↑

public class Ex02 {
	public static void main(String[] args) {	// 예외 처리가 필요 없다(자체 내장)
		
		Scanner sc = new Scanner(System.in);
		
		System.out.print("이름을 입력하세요 : ");
		String name = sc.nextLine(); 	// br.readLine();
		// nextLine() : 버퍼에 입력받은 내용중에서 개행문자 이전까지의 내용을 문자열로 반환(개행문자는 사라짐)
		
		System.out.print("나이를 입력하세요 : ");
		int age = sc.nextInt();			// 각 자료형에 맞는 입력도 제공한다
		// nextInt() : 버퍼에서 정수에 해당하는 값만 가져와서 반환한다 (개행문자 처리되지 않음)
		
		System.out.printf("%s님의 나이는 %d살입니다\n", name, age);
		
		sc.close(); 	// 사용이 끝난 스캐너는 꼭 닫아주자 (수도꼭지를 잠그는 느낌)
	}
}
=====================================================================================
package input;

import java.util.Scanner;

public class Ex03 {
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		
		String name, address;
		int age;
		
		System.out.print("이름 입력 : ");
		name = sc.nextLine();
		
		System.out.print("나이 입력 : ");
		age = sc.nextInt();	// 정수만 가져가고, 개행문자를 처리하지 않는다는 문제
		sc.nextLine();		// 개행문자를 처리하는 함수를 호출(변수에는 저장할 필요가 없다)
		
		System.out.print("주소 입력 : ");
		address = sc.nextLine();
		
		System.out.printf("%s님은 %d살이고, 사는 곳은 %s입니다\n", name, age, address);
		
		// 해결방법 1) nextLine() 대신 next()
		// next() 개행문자 혹은 띄워쓰기 이전까지의 내용을 가져감
		// next() 는 띄워쓰기를 포함한 문자열을 입력받지 못한다
		
		// 해결방법 2) 정수나 다른 자료형을 입력받은 후, nextLine()을 한번 더 호출한다

		// 해결방법 3) 모든 데이터는 nextLine()을 활용하여 문자열로 입력받고, 필요하면 형태를 변환한다
		
		System.out.print("정수 입력 : ");
		int n1 = Integer.parseInt(sc.nextLine()); // 숫자가 아닌 값이 포함되면 예외 발생
		
		System.out.print("문자열 입력 : ");
		String str = sc.nextLine();
		
		System.out.println("n1 : " + n1 + ", str : " + str);
		
		sc.close();
	}
}

====================================================================================
package input;

import java.util.Scanner;

public class Quiz01 {
	public static void main(String[] args) {
		
		// Scanner를 활용하여 사용자의 정보를 입력받고, 화면에 출력하세요
		// 사용할 id, 한글 이름, 생년월일 6자리, email 주소를 입력받으면 됩니다
		// 출력은 항목당 1줄씩 출력하고, \t 를 활용하여 항목 이름과 항목값이 나란히 출력되도록 하세요
		
		// ID	: itbank
		// 이름	: 나단비
		
		Scanner sc = new Scanner(System.in);
		
		String id, name, email;
		String birth;
		
		System.out.print("ID 입력 : ");
		id = sc.nextLine();
		
		System.out.print("이름 입력 : ");
		name = sc.nextLine();
		
		System.out.print("생년월일(6자리) 입력 : ");
		birth = sc.nextLine(); //970103 입력
		// 입력받은 6자리의 정수에서 년,월,일을 구분하여 각각의 변수에 저장하세요
		int year, month, day;

		// 1) % 연산자를 이용하여 숫자를 원하는 자릿수만큼 끊어서 저장하기
		int birth2 = Integer.parseInt(birth); //970103
		day = birth2 % 100; // 03
		birth2 = birth2 / 100; // 9701
		month = birth2 % 100; // 01
		year = birth2 / 100; //97
		System.out.printf("%02d년 %02d월 %02d일\n", year, month, day);
		
		// 2) 문자열의 기능을 활용하여, 2자리씩 끊어서 저장하기
		String year2, month2, day2;
		year2 = birth.substring(0, 2);	// 문자열.substring(시작인덱스, 마지막인덱스);
		month2 = birth.substring(2, 4);	// 마지막 인덱스는 범위에 포함하지 않는다
		day2 = birth.substring(4);		// 마지막 인덱스를 생략하면 문자열의 끝까지
		System.out.printf("%s년 %s월 %s일\n", year2, month2, day2);
		
		System.out.print("이메일 입력 : ");
		email = sc.nextLine();
		
		System.out.println();
		
		System.out.println("ID\t : " + id);
		System.out.println("이름\t : " + name);
		System.out.printf("생년월일\t : %s\n", birth);
		System.out.println("이메일\t : " + email);
		
		sc.close();
	}
}
================================================================================
#)자바에서 난수를 얻어내는 방법은 Random, Math클래스를 활용하는 2가지방법이있다.
Math.random()메소드는 0.0~1 사이의 double난수를 얻는데만
Random은 boolean, int, long, float, double 난수 얻을수있다.

public class RandomExample {
    public static void main(String[] args)  {
        System.out.println("0.0 ~ 1.0 사이의 난수 1개 발생 : " + Math.random());
        System.out.println("0 ~ 10 사이의 난수 1개 발생 : " + (int)((Math.random()*10000)%10));
        System.out.println("0 ~ 100 사이의 난수 1개 발생 : " + (int)(Math.random()*100));
		System.out.println("1 ~ 10사이의 난수 1개 발생 : " + (int)(Math.random()*10)+1);
	}
}
=================================================================================
import java.util.Random;

public class RandomExample {
	public static void main(String[] args)  {

        Random rd = new Random();//랜덤 객체 생성
    
        for(int i=0;i<6;i++) {
            System.out.print("["+(rd.nextInt(45)+1)+"]"); //로또번호 출력
        }
    }
}
결과: [28][41][19][34][22]
=====================================================
public static void main(String[] args) {
	int b = 100;
	int a = 10;
	// 10~100
	int mRandomResult = (int)(Math.random() * ((b-a) + 1)) +a;
}

=======================================================
#) 10 ~ 100
double min = 10;
double max = 100;
double random = (int) ((Math.random() * (max - min)) + min);
System.out.println(random);
========================================================
package operator;

import java.util.Scanner;

public class Ex05 {
	public static void main(String[] args) throws Exception {
		
		// char는 글자를 출력하기 위한 자료형이면서, 내부 데이터는 정수로 저장된다
		// 정수간의 비교는 == 연산자를 이용한다
		// Scanner에서는 한글자(char)를 입력받는 함수가 없다
		
		// System.in.read()
		
		// sc.next().charAt(0)
		// sc.nextLine().charAt(0)
		
		char ch1, ch2, ch3;
		Scanner sc = new Scanner(System.in);
		
		System.out.print("글자 하나 입력 : ");
		ch1 = (char)System.in.read();		// 모든 글자는 원래 정수형태로 저장한다 !!
		System.in.read();		// \r
		System.in.read();		// \n
		
		System.out.print("글자 하나 입력 : ");
		ch2 = sc.next().charAt(0);
		sc.nextLine();
		
		System.out.print("글자 하나 입력 : ");
		ch3 = sc.nextLine().charAt(0);
		
		System.out.println("ch1 : " + ch1);
		System.out.println("ch2 : " + ch2);
		System.out.println("ch3 : " + ch3);
		
		sc.close();
		
	}
}

=========================================================================
package operator;

import java.util.Scanner;

public class Quiz02 {
	public static void main(String[] args) {
		
		// 나이를 정수로 입력받고, 삼항 연산자를 활용하여 성인 혹은 미성년자 여부를 출력하는 코드 만들기
		// 20세부터 성인으로 처리하기
		// visual c++ 6.0
		
		// 1) 변수 선언 (초기화 가능하면 초기화까지 진행)
		int age;
		String adult;
		String result = "나이는 %d살이고, %s입니다\n";
		Scanner sc = new Scanner(System.in);
		
		// 2) 입력 받기
		System.out.print("나이를 입력 : ");
		age = sc.nextInt();
		
		// 3) 데이터 연산을 통해 결과를 준비
		adult = age >= 20 ? "성인" : "미성년자";
		// age의 값이 20보다 크거나 같으면, "성인" 이라는 문자열 값을 adult에 담고, 아니면 "미성년자"를 대입
		
		// 4) 결과를 출력
		System.out.printf(result, age, adult);
		
		// 5) 마무리 작업
		sc.close();
	}
}

=====================================================================
package operator;

import java.util.Scanner;

public class Quiz03 {
	// 단항, 이항, 삼항
	
	public static void main(String[] args) {
		// 한 글자를 입력받아서, 글자가 산술연산자(+,-,*,/,%)인지 아닌지 판별하는 코드를 작성
		char oper;
		Scanner sc = new Scanner(System.in);
		String result;
		boolean isOperator;
		
		System.out.print("연산자를 입력 : ");
		oper = sc.nextLine().charAt(0);
		
		//true, false 판단
		isOperator = oper == '+' || 	// 비교 연산자는 이항 연산이므로, 변수이름과 값을 같이 적자
					 oper == '-' || 	// 논리 연산자의 결과는 boolean 타입으로 저장된다
					 oper == '*' || 	// or 연산의 경우, 앞의 조건이 참이면 나머지 조건은 확인하지 않는다
					 oper == '/' || 	// and 연산의 경우, 앞의 조건이 거짓이면 나머지 조건은 확인하지 않는다
					 oper == '%';		// ;을 입력하기 전까지는 한 줄로 취급한다
		
		result = "연산자";
		result += isOperator ? "입니다" : "가 아닙니다";		// 삼항 연산의 값이 결정되면 그 값을 더한다
		
		System.out.printf("%c(은/는) %s\n", oper, result);
		
		sc.close();
		
		// 대입연산의 좌변은 무조건 변수가 와야한다 (상수 불가능)
//		"우리집" = "부산"; 		// (X)
		String 우리집 = "부산";	// 사용 가능하지만, 변수이름을 한글로 하는 경우는 거의 없다
		
	}
}

============================================================
package operator;

import java.util.Scanner;

public class Quiz04 {
	public static void main(String[] args) {
		
		int n1, n2;
		Integer answer;
		char oper;
		Scanner sc = new Scanner(System.in);
		
		System.out.print("정수1 입력 : ");
		n1 = Integer.parseInt(sc.nextLine());
		
		System.out.print("연산자 입력 : ");
		oper = sc.nextLine().charAt(0);
		
		System.out.print("정수2 입력 : ");
		n2 = Integer.parseInt(sc.nextLine());
		
		// answer의 값을 결정
		
		answer = (oper == '+') ? n1 + n2 :
				 (oper == '-') ? n1 - n2 :
				 (oper == '*') ? n1 * n2 :
			     (oper == '/') ? n1 / n2 :
			     (oper == '%') ? n1 % n2 : null;	// null : 객체가 없다
		
		String result = String.format("%d %c %d = %d\n", n1, oper, n2, answer);
		System.out.println(answer != null ? result : "연산자가 잘못되었습니다");
		
//		The local variable answer may not have been initialized
		
		sc.close();
		
		
		
	}
}
====================================================================
package controlStatement;

import java.util.Scanner;

public class Ex02 {
	public static void main(String[] args) {
		//시간을 입력받고, 금액을 계산
		//기본요금은 3000원, 10분이 추가될 때 마다 추가요금이 500원씩 발생
		// 3500 39분
		// 3500 40분
		// 4000 41분
		// 4000 49분
		Scanner sc = new Scanner(System.in);
		System.out.print("시간입력: ");
		int min = sc.nextInt();
		int price = 3000;
		if(min > 30) {
			min = min - 30;
			if(min % 10 == 0) {
				price = price + (min / 10) * 500;
				System.out.println("주차요금은: "+price+"원");
			}
			else {
				price = price + (min / 10) * 500;
				price += 500;
				System.out.println("주차요금은: "+price+"원");
			}
		}
		else {
			System.out.println("주차요금은: "+price+"원");
		}
	}
}

==================================================================
String 클래스의 인스턴스는 한 번 생성되면 읽기만 할 수 있고 변경은 불가,

StringBuffer 클래스의 인스턴스는 그 값을 변경할 수 있고, 추가도 할 수 있음

StringBuffer 클래스는 내부적으로 buffer(버퍼)라고 하는 독립적인 공간을 가짐
버퍼 크기의 기본값은 16개의 문자를 저장할 수 있는 크기이며,
생성자를 통해 크기를 별도로 설정할 수 있음
인스턴스 생성시 사용자가 설정한 크기보다 언제나 16개의 문자를
더 저장할 수 있도록 여유있는 크기로 생성됨
#)contentEqulas는 내용만 비교 String의 인스턴스인지도 확인하지 않는다
public class StrMethod {
    public static void main(String[] args) {
        String a = "abc";
        String b = "abc";
        StringBuffer c = new StringBuffer("abc");

        // str.quals() 메소드
        System.out.println(a.equals(b));    // true
        System.out.println(a.equals(c));    // false

        // str.contentEquls() 메소드
        System.out.println(a.contentEquals(b)); // true
        System.out.println(a.contentEquals(c)); // true
    }
}
===============================================================
package controlStatement;

import java.util.Scanner;

public class Ex03 {

	public static void main(String[] args) {
		
		//switch ~ case
		//모든 switch case는 if문으로 대체가능 그래서 python은 switch가 없다
		//case에는 일반적으로 break로 마무리
		//자바의 switch는 문자열비교도 가능하다
		
		//default는 else의 역할
            // primitive는 == 연산자로 일치여부를 비교할 수 있지만, Reference Type은 그렇지 않다
            
            // 1번과 2번이 같은 이유 : 프로그램이 실행되기 전에 상수 데이터를 먼저 메모리에 준비하는데
            // 기존에 준비된 상수가 똑같이 다른 변수에서 사용되면, 하나의 상수 주소를 서로 다른 변수에게 똑같이 전달
            
            // 1번과 3번이 다른 이유 : new 연산자는 메모리 상에 새로운 공간을 할당받아서 내용을 만든다
            // malloc()
            
            // 1번과 4번이 다른 이유 : 사용자에게 입력받기 위한 변수는 어떤값이 들어올지 모르니까 공간을 새로 할당받는다
            
            Scanner sc = new Scanner(System.in);
            String str1 = "Hello";
            String str2 = "Hello";
            String str3 = new String("Hello");
            String str4;
            
            System.out.print("Hello 라고 입력하세요 : ");
            str4 = sc.nextLine();
            
            // 각 참조변수가 같은 객체를 참조하고 있는가(같은 대상을 바라보고 있는가)
            System.out.println(str1 == str2);
            System.out.println(str1 == str3);
            System.out.println(str1 == str4);
            
            // 문자열끼리 내용의 일치여부를 판별하려면
            System.out.println(str1.equals(str2));                        // 객체(String)간의 내용 비교
            System.out.println(str1.contentEquals(str3));        // 문자열과 준 문자열간의 내용만 비교
            System.out.println(str1.equalsIgnoreCase(str4));// 문자열끼리 비교(대소문자 구분없이)
            
            sc.close();
			
			switch(str4) {  //알아서 비교해준다.
			case "Hello":
				System.out.println("안녕하세요");
				break;
			case "apple": {
				System.out.println("사과는 맛있다.");
				break;
			}
    }
	}

}
=============================================================================
package controlStatement;

import java.util.Scanner;

public class Quiz02 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int kor,eng,math,total;
		double avg;
		char grade;
		System.out.print("국어 성적입력: ");
		kor = sc.nextInt();
		System.out.print("영어 성적입력: ");
		eng = sc.nextInt();
		System.out.print("수학 성적입력: ");
		math = sc.nextInt();
		total = kor+eng+math;
		avg = total / 3.0;
		switch((int)avg/10) { //switch문에서는 소수를 못넣는다.
		case 10:
		case 9: 
			grade='A'; 
			break;
		case 8: 
			grade='B'; 
			break;
		case 7: 
			grade='C'; 
			break;
		case 6: 
			grade='D'; 
			break;
		default:
			grade='F';
			break;
		}
		System.out.println("합계: "+total);
		System.out.printf("평균: %.2f\n",(total / 3.0));
		System.out.println("학점: "+grade);
		sc.close();
	}
}
==============================================================================
package star;

public class ex01 {
	public static void main(String[] args) {
		int length=5;
		int space = 2;  // space = 2
		int star = 1;  //star = 1
		
		for(int i=0; i<length; i++) {
			for(int j=0; j<space; j++) {
				System.out.print("  ");
			}
			for(int j = 0; j<star; j++) {
				System.out.print("* ");
			}
			for(int j=0; j<space; j++) {
				System.out.print("  ");
			}
			System.out.println();  //여기까지가 한줄
			if(i < length / 2) {  //상단기준
				space -= 1;   //한줄씩 증가하면 공백은 1씩감소
				star += 2;
			}
			else { //하단기준
				space += 1;
				star -= 2;
			}
		}
	}
}
    *
  * * *
* * * * *
  * * *
    *
======================================================================
package loop;

public class Ex03 {

	public static void main(String[] args) {
		int length=5;
		int space = -1;
		int star = length /2 + 1;  
		for(int i=0; i<length; i++) {
			for(int j = 0; j<star; j++) {
				System.out.print("* ");
			}
			for(int j=0; j<space; j++) {
				System.out.print("  ");
			}
			for(int j = 0; j<star; j++) {
				//첫줄이나 마지막줄이면서 동시에 j의 마지막칸인경우 *을 출력안한다.
				if((i==0 || i==length-1 )&& j==star-1) {
					break;
				}
				System.out.print("* ");
			}
			System.out.println();  //여기까지가 한줄
			//반복문에서  - (마이너스)는 수행을안한다.
			star += (i<length / 2) ? -1 : 1;
			space += (i<length / 2) ? 2  : -2;
		}
	}
}
* * * * * 
* *   * * 
*       * 
* *   * * 
* * * * * 
=====================================================================
package loop;

import java.util.Scanner;

public class Quiz02 {

	public static void main(String[] args) {
		char i = 65;
		while(i<=90) {
			if(i==90) {
				break;
			}
			System.out.print(i+", ");
			i++;
		}
		System.out.println(i);
		System.out.println();
		
		//2번(거꾸로 수 출력1)
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력: ");
		int num = sc.nextInt();
		while(num != 0) {
			System.out.print(num % 10);
			num /= 10;
		}
		System.out.println();
		
		//2번(거꾸로 수 출력2)
		System.out.print("정수입력: ");
		int num1 = sc.nextInt();
		int tot=0;
		while(num1 != 0) {
			tot = tot * 10 + num1 % 10;
			num1 /= 10;
		}
		System.out.println(tot);
		
		//5번)임의의 패스워드를 문자열로 설정하고, 사용자에게 문자열을 입력받아 일치할때까지 입력받아라
		while(true) {
			System.out.print("패스워드 입력: ");
			String pw = sc.next();
			if(pw.equals("hello")) {
				System.out.println("패스워드일치");
				break;
			}
		}
	}

}
===============================================================================
System.out.printf("총 금액: %,d원\n", tot);
==============================================================================
package function;

public class Ex01 {
	//객체를 통하지않고 호출하는 즉, main에서의 함수는 static을 붙힌다.
	static int add(int n1, int n2) {
		int result = n1+n2;
		return result;
	}
	
	public static void main(String[] args) {
		int num = add(11,23);
		System.out.println("결과: "+num);
	}
}
=====================================================================================
package array;

public class Ex01 {

	public static void main(String[] args) {
		//단일 데이터를 저장하기 위한 메모리 공간 - 변수
		//같은 자료형의 여러 데이터를 저장하기 위한 연속된 메모리 공간 - 배열
		
		int arr1[] = { 2, 7, 3 };
		int[] arr2 = {10,20,30};
		int[] arr3 = new int[5];
		int[] arr4 = new int[] {11,22,33};
		//int[] fail = new int[5] { -1, -2, -3, -4, -5}; 에러
		
		//배열은 reference type으로 취급된다. -> 그래서 초기화가 자료형에 맞게 된다.
		System.out.println(arr3[2]); // 0으로 초기화된다.
		
		String[] arr5 = {"이지은", "홍진호", "나단비"};
		int[] arr6 = {29,40,5};
		String[] arr7 = new String[5];
		
		System.out.println(arr7[0]); //null출력
		
		for(int i=0; i<arr5.length; i++) {
			System.out.printf("%d번째 멤버의 이름은 %s입니다.", i, arr5[i]);
		
		System.out.println(arr5); //이렇게하면 요소내용을 알 수 없다. 
		}
		
		for(String name : arr5) { // i번쨰 요소 이런거 상관없이 그냥 모든 요소출력 시 이거사용
			System.out.println(name);
		}
		
		int[] arr8 = null;
		//arr1, arr8이 {2,7,3}을 바라본다. 그래서 요소를 하나 수정하면 arr1,arr8에서 보면 다 수정되있다.
		arr8 = arr1; //arr1이 가지는 값을 arr8에 복사하여 대입
		System.out.println(arr8); //해시테이블출력
		arr8[0] = 3; //서로다른 참조변수를 만들었을뿐, 대상이 되는 배열은 하나만 존재
		System.out.println(arr1[0]);
 		
		arr8[1] = arr8[0]; 
		
		int arr9[] = {2,7,5};
		int arr10[] = new int[3];
		
		//배열요소 복사
		for(int i =0; i<arr9.length; i++) {
			arr10[i] = arr9[i];
		}
	}

}
==========================================================================================
package array;

public class Quiz03 {
	public static void main(String[] args) {
		
		// 1) 정수형 배열을 arr1에 선언하세요
		//    구성 요소는 11, 9, 23, 54, 27, 36, 2, 7 입니다
		int[] arr1 = { 11, 9, 23, 54, 27, 36, 2, 7 };
		
		// 2) 위에서 선언한 배열의 요소를 한줄에 출력하세요
		//    각 요소는 콤마로 구분하여 출력하고 마지막에는 줄바꿈이 들어가야 합니다
		System.out.print("arr1 : ");
		for(int i = 0; i < arr1.length; i++) {
			System.out.print(arr1[i] + (i == arr1.length - 1 ? "\n" : ", "));
		}System.out.println();
		
		// 3) 위에서 선언한 배열에서 요소의 값이 홀수인 값만 찾아서 합계를 구하여 출력하세요
		int oddSum = 0;
		for(int num : arr1) {
			if(num % 2 == 1) 
				oddSum += num;
		}
		System.out.println("홀수의 합 : " + oddSum);
		
		// 4) 위에서 선언한 배열에서 요소의 값이 짝수인 값만 찾아서 합계를 구하여 출력하세요
		int evenSum = 0;
		for(int num : arr1) {
			if(num % 2 == 0) 
				evenSum += num;
		}
		System.out.println("짝수의 합 : " + evenSum);
		
		// 5) 새로운 배열 arr2를 arr1의 길이와 똑같은 크기로 선언하세요
		int[] arr2 = new int[arr1.length];
		
		System.out.print("\narr2 : ");
		for(int i = 0; i < arr2.length; i++) {
			System.out.print(arr2[i] + (i == arr2.length - 1 ? "\n" : ", "));
		}System.out.println();
		
		// 6) arr1의 구성요소를 순서를 반대로 arr2에 넣은 다음 2번 문제의 요령으로 출력하세요
		for(int i = 0, j = arr1.length - 1; i < arr1.length; i++, j--) {
			arr2[i] = arr1[j];
		}
		
		System.out.print("\narr2 : ");
		for(int i = 0; i < arr2.length; i++) {
			System.out.print(arr2[i] + (i == arr2.length - 1 ? "\n" : ", "));
		}System.out.println();
		
	}
}
=====================================================================================
package function;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class Quiz01 {
	public static void main(String[] args) {
		// 주민등록번호 13자리를 입력받으세요
		// 주민등록번호 앞자리와 뒷자리를 별도의 문자열로 입력받으세요
		// 입력받은 주민등록번호를 함수에게 전달하세요
		// 함수는 전달받은 앞자리와 뒷자리를 이용하여 출생년도 4자리, 월, 일, 성별을 문자열로 구성하고 반환하세요
		
		Scanner sc = new Scanner(System.in);
		String num1, num2, input;
		
		System.out.print("주민등록번호 입력 (13자리, -없이 입력) : ");
		input = sc.nextLine();
		num1 = input.substring(0, 6);
		num2 = input.substring(6);
		System.out.println(num1 + ", " + num2);
		
		String msg = getIdNumberData(num1, num2);
		String msg2 = getIdNumberData(Integer.parseInt(num1), Integer.parseInt(num2));
		// 자바에서는 클래스 단위로 코드를 읽어서 컴파일 이후 실행하기 때문에
		// 함수의 정의가 아래쪽에 있어도 상관없다
		
		System.out.println(msg);
		System.out.println(msg2);
		
		sc.close();
	}

	// 함수(메서드)의 이름은 원래 중복되면 안된다
	// 자바에서는 함수의 이름이 같아도 별도의 함수로 인정해줄 수 있는 규칙이 있다
	// 서로 다른 함수가 같은 이름을 공유하지만, 매개변수의 개수가 다르거나, 자료형이 다르면 서로 다른 함수로 구분가능
	// => 자바는 메서드 오버로딩이 가능하다
	// overload : 하나의 값에 두 개 이상의 역할이 부여되는 형태
	// network ip translation overload : 하나의 아이피에 여러대의 컴퓨터가 연결되어 있는 형태
	// 하나의 아이피를 공유하지만, 포트번호가 서로 다르기때문에 구별이 가능한 상황
	
	static String getIdNumberData(int num1, int num2) {
		// 정수형태로 처리하기
		int year, month, day, gNum;
		day = num1 % 100;
		num1 /= 100;
		month = num1 % 100;
		year = num1 / 100;
		year += 21 < year ? 1900 : 2000;
		gNum = num2 % 1000000;
		
		return String.format("%d년 %02d월 %02d일 출생한 %s입니다", 
				year, month, day, gNum % 2 == 0 ? "여성" : "남성");
	}

	static String getIdNumberData(String num1, String num2) {
		// 문자열 관련 함수를 활용해서 처리하기
		int nowYear = Integer.parseInt(new SimpleDateFormat("yy").format(new Date()));  //19
		String year = num1.substring(0, 2);	// for(int i = 0; i < 2; i++)  //97
		String month = num1.substring(2, 4);
		String day = num1.substring(4);
		String gender = Integer.parseInt(num2.substring(0, 1)) % 2 == 0 ? "여성" : "남성";
		year = Integer.parseInt(year) > nowYear ? "19" + year : "20" + year;
		
		return String.format("%s년 %s월 %s일 출생한 %s입니다", 
				year, month, day, gender);
	}
}
================================================================================================
package function;

public class Quiz02 {

	static void sample(String arg) {
		arg = arg.replaceAll(" ", "");	// arg의 모든 공백문자를 빈문자열로 변환
		
		// 모든 문자열은 length() 를 호출하여 문자열의 길이를 확인할 수 있다(정수)
		for(int i = 0; i < arg.length(); i++) {
			char ch = arg.charAt(i);
			System.out.println(ch);
		}
	}
	static int getAscii(String ar) { // getAscii 오버로딩
		return (int)ar.charAt(0);
	}
	static int getAscii(char ar) {
		return (int)ar;
	}
	static int getAscii(int ar) {
//		return ar + 48;				
		// '0'의 아스키코드가 48이고, 각 정수에 48을 더하면 아스키 코드가 나온다
		
		return getAscii(ar + "");	
		// 빈 문자열을 더하면 자료형이 String이 된다. String을 처리하는 코드를 불러서 쓴다
	}
	
	public static void main(String[] args) {
		// 글자를 전달하면 글자의 아스키 코드를 정수로 반환하는 함수를 작성하세요
		// 처리할 수 있는 매개변수의 자료형은 String, int, char
		// 문자열은 첫번째 글자의 아스키코드를 처리하세요
		// 만약 아스키코드로 표현이 불가능한 글자이면(한글, 중국어, 일본어 등등..) -1을 반환하세요
		
		int code1 = getAscii("A");	// 65
		int code2 = getAscii('b');	// 98
		int code3 = getAscii(5);	// 53
		
		System.out.printf("%d, %d, %d\n", code1, code2, code3);
		
	}
}

======================================================================================
package array;

public class Ex01 {
	public static void main(String[] args) {
		// 중첩된 배열, 2차원 배열
		
		int[][] arr = new int[5][5];
		
		System.out.println(arr.length);
		System.out.println(arr[0].length);
		
		int num = 0;
		for(int i = 0; i < arr.length; i++) {
//			System.out.println(arr[i]);
			for(int j = 0; j < arr[i].length; j++) {
				arr[i][j] = ++num;
				System.out.printf("%2d ", arr[i][j]);
			}
			System.out.println();
		}
		System.out.println();
//		==================================================
		int[][] arr2 = {
				{ 1, 2, 3, 4, 5 },  -> 00 01 02 03 04
				{ 6, 7, 8, 9, 10 },	
				{ 11, 12, 13, 14, 15 }, 
				{ 16, 17, 18, 19, 20 },	
				{ 21, 22, 23, 24, 25 }, 
		};
		for(int i = 0; i < arr2.length; i++) {
			for(int j = 0; j < arr2[i].length; j++) {
				System.out.printf("%2d ", arr2[i][j]);
			}
			System.out.println();
		}
		System.out.println();
		
		int[][] arr3 = {
			{ 1, 2, 3, 4, 5 }, { 6, 7, 8, 9, 10 },{ 11, 12, 13, 14, 15 },{ 16, 17, 18, 19, 20 },{ 21, 22, 23, 24, 25 }, 
		};
		
	}
}
=========================================================================================
package array;

public class Ex02 {
	public static void main(String[] args) {
		int[] arr1 = { 1, 2, 3, 4, 5 };
		int[] arr2 = { 6, 7, 8, 9, 10 };
		int[] arr3 = { 11, 12, 13, 14, 15 };
		
		int[][] arr = { arr1, arr2, arr3 };
		
		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				System.out.printf("%2d ", arr[i][j]);
			}
			System.out.println();
		}
		System.out.println();
		
		// 참고 - http://pythontutor.com/java.html
		
		int[][] arr4 = new int[5][];
		// 2차원 배열 생성시, 마지막 길이는 생략이 가능하다
		// 1차원 정수 배열을 멤버로 참조할 수 있는 2차원 배열 arr4를 길이 5로 선언
		// 참조할 수 있다는 말은, 값이 있어야 참조할 수 있고, 초기값은 null이다 (대상이 없다)
		
		for(int i = 0; i < arr4.length; i++) {
			System.out.println(arr4[i]);
			for(int j = 0; j < arr4[i].length; j++) {
				System.out.println(arr4[i][j]);
			}
		}
		// 실제 내부 배열이 존재하지 않기 때문에 NullPointerException 이 발생한다
		// 참조하는 대상이 없는데, 대상의 특정 속성이나 기능을 호출하려고 하면 발생하는 예외
		
		
		
		
		
	}
}
========================================================================================
package array;

public class Quiz01 {
	
	public static void main(String[] args) {
	
		// 가로 6, 세로 5 크기의 2차원 배열을 생성하고
		// 정수 1부터 30까지 순서대로 값을 담은 후
		// 2차원 배열을 전달하면 화면에 2차원 배열의 각 요소를 순서대로 출력하는 함수를 작성하여
		// 화면에 출력하세요 (반환형 void)
		int[][] arr = new int[5][6];
		int num = 0;
		
		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				arr[i][j] = ++num;  // 00 01 02 03 04 ...
			}
		}
		printArray(arr);
	}
	static void printArray(int[][] arr) {
		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				System.out.printf("%2d ", arr[i][j]);
			}
			System.out.println();
		}
		System.out.println();
	}

}

======================================================================================
package 평가1A;

import java.util.Scanner;

public class CardNumber {
	// 2720992711828767 => 80
	// 6011733895106094 => 60
	// 3444063910462763 => 76
	
	static boolean isValid(char[] arr) {
		if(arr.length != 16) {
			return false;
		}
		
		int sum = 0;
		for(int i = 0; i < arr.length; i++) {
			if('0' > arr[i] || arr[i] > '9') {	// 범위를 벗어나면 (비교대상 값을 포함하지 않는 범위)
				return false;
			}
			int num = arr[i] - 48;	// '0'의 아스키코드는 48이고, 글자에서 48을 빼면 정수가 나온다
//			System.out.print(num + " ");
			if(i % 2 == 0) {
				num *= 2;
				if(num >= 10) {
					num = num / 10 + num % 10;	// 10의 자리 정수와 1의 자리 정수를 더한다
				}
			}
			sum += num;
		}
//		System.out.println(sum);
		return sum % 10 == 0;
	}
	
	// 1) 자료형
	// 2) 사용자의 입력은 대부분 문자열 형태로 처리하는것이 무난하다 (어떤 문자든 입력받을 수 있다)
	// 3) 문자열로 입력받은 데이터를 문자열 관련 함수를 통해서 변형하는 방법이 많다 (구글링)
	// 4) 함수의 매개변수와 인자값, 반환자료형
	// 5) 제어문 내부에서 또다른 제어문을 쓰는 연습을 해야 헷갈리지 않는다 !!
	
	public static void main(String[] args) {
		// 입출력은 메인함수에서만 (-를 포함할수도 있고, 숫자만 입력할 수도 있다)
		// 사용자 함수는 char[] 을 받아서 boolean 을 반환하는 형식
		// 우측부터 세어서 1번째(홀수)는 그대로 2번째(짝수)는 2배(10넘어가면 각 자릿수 합치기)
		// 모든 16개의 숫자를 합친 결과가 10으로 나누어 떨어지면 유효
		
		Scanner sc = new Scanner(System.in);
		String input, result;
		boolean valid;
		
		System.out.print("카드 번호를 입력 : ");
		input = sc.nextLine();
		
		input = input.replace("-", "");
		
		valid = isValid(input.toCharArray());	// y = f(x)  //숫자를 문자로 바꿧기때문에 0은 48부터 시작
		
		result = input.substring(0, 4) + "-" +
				input.substring(4, 8) + "-" +
				input.substring(8, 12) + "-" +
				input.substring(12);
		
		System.out.println(valid ? result + " : 유효" : "유효하지 않음");
		sc.close();
	}
}
=========================================================================================
package 평가1A;

public class MiddelCharacter {
	// 홀짝, %
	// substring
	// 문자열의 길이(홀짝)에 따라서 가운데 인덱스를 찾아내라

	public static void main(String[] args) {
		
		String test1 = solution("abcde"); //solution이라는 함수에전달
		String test2 = solution("qwer");  //solution이라는 함수에전달
		
		System.out.println("c".equals(test1));
		System.out.println("we".equals(test2));
	}
	static String solution(String s) {
		String answer = "";
		boolean isEven = s.length() % 2 == 0;		// 길이가 짝수인지 판별
		if(isEven) {								// 짝수이면
			answer += s.charAt(s.length() / 2 - 1); // 가운데 한칸 앞의 글자를 먼저 추가한다
		}	
		answer += s.charAt(s.length() / 2);			// 홀짝에 상관없이 가운데 글자를 추가한다
		return answer;								// 완성된 문자열을 반환
	}
	
//	static String solution(String s) {
//		String answer = "";
//		
//		boolean isEven = s.length() % 2 == 0;	// 홀짝 판단
//		int beginIndex = s.length() / 2;		// 시작 인덱스
//		beginIndex -= isEven ? 1 : 0;			// 짝수이면 1을 뺀다
//		int endIndex = s.length() / 2 + 1;		// 마지막 인덱스 (홀짝 여부에 상관없이 고정)
//		answer = s.substring(beginIndex, endIndex);	// 구한 인덱스값으로 문자열을 추출
//		
//		return answer;							// 추출한 문자열을 반환
//	}
}
=============================================================================================
package 평가1A;

//	2021 KAKAO BLIND RECRUITMENT
//	신규 아이디 추천

public class NewId {
	public static void main(String[] args) {
		String input = "...!@BaT#*..y.abcdefghijklm";
		String expected = "bat.y.abcdefghi";
		
		String result = solution(input);
		System.out.println(expected.equals(result));
	}

	static String solution(String new_id) {
		String answer = "";
		
//		1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.
		new_id = new_id.toLowerCase();
		
//		2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.
		String test = "abcdefghijklmnopqrstuvwxyz0123456789-_."; //test에 소문자,숫자,뺴기,밑줄,마침표를 넣어놓고
		for(int i = 0; i < new_id.length(); i++) {
			if(test.contains(new_id.charAt(i) + "")) { 	// 정수에 문자열을 더하면 결과는 문자열이다
				answer += new_id.charAt(i);				// answer가 문자열이므로, 이어붙이기
			}
		}
		
//		3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.
		while(answer.contains("..")) { 	// while == 반복되는 if
			answer = answer.replace("..", ".");
		}
		
//		4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.
		if(answer.charAt(0) == '.') {
			answer = answer.substring(1);
		}
		if(answer.length() > 0 && answer.charAt(answer.length() - 1) == '.') {
			answer = answer.substring(0, answer.length() - 1);	// endIndex는 포함하지 않음
		}
			
//		5단계 new_id가 빈 문자열이라면, new_id에 "a"를 대입합니다.
//		if(answer.equals("")) {
		if("".equals(answer)) {
			answer = "a";	// 변수와 상수간의 비교라면, 상수를 앞에다가 두자 (NPE 방지)
		}
		
//		6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.
//		만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.
		if(answer.length() >= 16) {
			answer = answer.substring(0, 15);
		}
			// 5단계에서 "a" 를 대입하므로, 문자열의 길이가 0일 걱정을 안해도 된다
		if(/*answer.length() > 0 &&*/ answer.charAt(answer.length() - 1) == '.') {
			answer = answer.substring(0, answer.length() - 1);
		}
		
//		7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.
		while (answer.length() < 3) {
			answer += answer.charAt(answer.length() - 1);
		}
		return answer;
	}
}
==========================================================================================
package 평가1A;

public class StringMethod {
	public static void main(String[] args) {
		String str1 = "2720-9927-1182-8767";
		String[] split = str1.split("-");	// 제시한 글자를 기준으로 각 문자열을 분리하여 배열로 반환
		
		for(int i = 0; i < split.length; i++) {
			System.out.println(split[i]);
		}

		// root:x:0:0:root:/root:/bin/bash
		String str2 = "root:x:0:0:root:/root:/bin/bash";
		String[] split2 = str2.split(":");
		for(String s : split2) {
			System.out.println(s);
		}
		
		String str3 = "사과, 복숭아, 수박, 딸기, 포도, 오렌지";
		String[] split3 = str3.split(", ");
		for(String fruit: split3) {
			System.out.println(fruit);
		}
		
		System.out.println(str3.indexOf("수박")); // 제시한 내용이 문자열의 몇번째 인덱스에 위치하는가
		System.out.println(str3.indexOf("바나나"));// 제시한 내용이 없으면 -1
		System.out.println(str3.contains("바나나"));// 제시한 내용을 포함하는지 boolean으로 반환
		System.out.println(str3.length()); 	// 문자열의 길이를 정수로 반환
		
		System.out.println(str3.substring(21));		// 21번째 인덱스부터 끝까지
		System.out.println(str3.substring(4, 7));	// 4부터 6까지 (마지막은 포함하지 않음)
		
		// 앞부분에 공통으로 포함되는 문자열이 있으면 앞쪽에서 특정 문자열을 제외시킬 수 있다
		String url = "http://www.naver.com";
		System.out.println(url.substring("http://".length()));
		
		String str4 = "home.html";
		System.out.println(str4.replace(".html", ".jsp"));
		// 앞쪽의 문자열을 찾아서 뒤의 문자열로 내용을 변경
		
		System.out.println(str2.replace(":", "-"));	// 원본을 변경하지 않고, 새로운 문자열 반환
		System.out.println(str2);
		
		str2 = str2.replace(":", ".");
		System.out.println(str2);
		
		String str5 = String.format("%s님의 나이는 %d살입니다\n", "이지은", 29);
		System.out.println(str5);
		
		System.out.println("Hello".equals("Hello"));
		
		String str6 = "Apple";
		
		System.out.println(str6.toLowerCase());
		System.out.println(str6.toUpperCase());
		
	}
}

=================================================================================================
package dataType;

// 자바 소스코드에서 public class 는 하나만 존재할 수 있다
// public class의 이름과 소스코드의 이름은 일치해야 한다
// 같은 package 내부의 클래스끼리는 import 없이 참조가 가능하다
// 클래스의 이름은 첫글자를 대문자로 처리한다

class Student {	// 내가 프로그램에서 사용할 학생이라는 형태를 정의하는 코드
	// 변수, 속성, 멤버필드
	String name;
	int age;
	
	// 함수, 기능, 멤버메서드
	void show() {	// 메서드 내부에서 필드를 참조할 수 있다
		System.out.printf("제 이름은 %s이고, 나이는 %d살입니다\n", name, age);
	}
}

public class Ex05 {
	public static void main(String[] args) {
		int test = 0;		// 지역 변수는 갈색, 클래스의 멤버필드는 파란색
		
		Student st1 = new Student(); 	// 클래스를 이용하여 객체를 생성하는 기본 문법
		// 객체의 멤버 요소에 접근하기 위해서는, 객체.멤버이름 으로 접근한다
		
		st1.name = "이지은";
		st1.age = 29;
		
		st1.show();
	}
}
===========================================================================
package dynamicArray;

import java.util.Scanner;

// 자바의 배열은 길이가 고정이다
// 사용자에게 계속 입력받아서 정수를 저장하고, 길이가 자동으로 증가하는 배열을 구현하세요
// 참조변수가 바라보는 대상을 바꿀수 있다는 특징을 이용합니다
// 사용자가 0을 입력하면 더이상 입력받지 않고, 지금까지 입력받은 모든 정수를 출력하고
// 배열의 길이를 출력한 이후 종료합니다
// 언제 끝날지 모르는 무한반복 while, 배열을 길이만큼 참조하는 for, 종료를 판단하는 if

public class Quiz01 {
	// day07프로젝트 Ex04.java 
	
	public static void main(String[] args) {
		
//		Scanner sc = new Scanner(System.in);
		String test = "1 2 3 4 5 11 22 33 44 55 0";
		Scanner sc = new Scanner(test);
		int length = 1;
		int[] arr = new int[length];	// 배열을 선언하면 멤버의 초기값은 0이다
		int[] tmp;
		
		WHILE : while(true) {
			for(int i = 0; i < arr.length; i++) {
				if(arr[i] == 0) {	// 빈 칸에만 정수를 입력받자
//					System.out.print("정수 입력 : ");
					arr[i] = sc.nextInt();
					if(arr[i] == 0) {  //입력받은 숫자가 0이면 종료
						break WHILE;
					}
				}
			}
			for(int num : arr) {
				if(num != 0) 
					System.out.print(num + " ");
			} System.out.println();
			length += 1;
			tmp = new int[length];
			// 길이가 더 큰 배열을 생성하고 arr에 입력받은 멤버 정수를 tep에복사(한칸이 남게됨)
			for(int i = 0; i < arr.length; i++) {
				tmp[i] = arr[i];
			}
			arr = tmp;	// tmp가 바라보는 배열을 arr도 똑같이 바라보게 한다
		}
		
		// 반복이 끝나면 배열의 처음부터 끝까지 출력하기
		for(int num : arr) {
			if(num != 0) 
				System.out.print(num + " ");
		} System.out.println();
		
		sc.close();
	}
}
=================================================================================
package oop;

//생성자가 없으면 JVM이 자동으로 작성한다(기본생성자)

//Student는 패키지안에 다른클래스에서 만들었기때문에 Student2로 생성했다. 
class Student2 {
	String name;
	int score;
	
	Student2(String name, int score) {
		this.name = name;  //외부에서 전달받은 name의 값을 멤버필드 name에 대입
		this.score = score;
	}
	
	void show() {
		System.out.printf("%s의 점수는 %d점입니다\n", name, score);
	}
}

public class Constructor {
	public static void main(String[] args) {
		Student2 st1 = new Student2("홍진호",22); //show는 호출안함
		
		
	}
}
=======================================================================================
package oop;

import java.util.Scanner;

class Student {
	String name;
	int score;
	
	void show() {
		System.out.println(name + "의 점수는" + score + "입니다");
	}
}

public class Ex01 {

	public static void main(String[] args) {
		Student st1 = new Student();
		Student st2 = new Student();
		Student st3 = new Student();
		
		Scanner sc = new Scanner(System.in);
		System.out.print("이름을 입력하세요: ");
		st1.name = sc.nextLine();
		System.out.print("점수를 입력하세요: ");
		st1.score = Integer.parseInt(sc.nextLine());
		
		System.out.print("이름을 입력하세요: ");
		st2.name = sc.nextLine();
		System.out.print("점수를 입력하세요: ");
		st2.score = Integer.parseInt(sc.nextLine());
		
		System.out.print("이름을 입력하세요: ");
		st3.name = sc.nextLine();
		System.out.print("점수를 입력하세요: ");
		st3.score = sc.nextInt();
		
		//선언과 동시에 초기화 하지 않을때는 아래처럼 해야된다.
		//Student[] stuArr = new Student[3];
		//stuArr = new Student[]{st1,st2,st3};
		
		//에러나는경우
		//stuArr = {s1,st2,st3};
		
		//선언과 동시에 초기화하는 경우
		Student[] link = new Student[] {st1,st2,st3};
		for(int i = 0; i<link.length; i++) {
			link[i].show(); 
		}
		//또는
		//for(Student tmp : stuArr) {
		// 		tmp.show();
		//}
		
		//또는
		//for(int i = 0; i<stuArr.length; i++) {
		//	Student tmp = stuArr[i];
		//	tmp.show();
		//}
	}

}
=====================================================================
package oop;

class Test { //default class -> 해당클래스를 같은oop패키지 내부면 사용가능
	private int pri = 1; //클래스 외부에서의 모든 접근을 막는다.
	int pac = 2; //같은 패키지내의 접근은 허용
	protected int pro = 3; //같은 패키지 + 상속관계간의 접근을 허용한다
	public int pub = 4; //모든 외부로부터의 접근을 허용한다.
	
	void showField() {
		System.out.println("pri : " + pri); //class내부라서 접근가능
		System.out.println("pac : " + pac);
		System.out.println("pro : " + pro);
		System.out.println("pub : " + pub);
	}
}

public class Ex03 {

	public static void main(String[] args) {
		Test ob1 = new Test();
		//ob1.pri = 5;
		ob1.pac = 5;
		ob1.pro = 5;
		ob1.pub = 5;
		
		//일반적으로, 필드는 private로 설정하여 외부로부터의 값 변경을 방지하고
		//메서드와 생성자는 public으로 설정하여 누구나 기능을 호출하여 사용할 수 있도록 한다.
		//이렇게 설정하면, 외부에서는 필드를 참조하여 출력할수도 없고
		//필드의 값을 지정하여 대입할 수도 없다.
		//따라서, 허용되는 기능을 통해서만 값을 참조하거나, 변경할수 있다.
		//이때 값을변경하는 메서드(setter), 값을 참조하는 메서드(getter)가 필요해진다.
		

	}

}
----------------
package oop;

public class EX03_sub {

	public static void main(String[] args) {
		//EX03_sub가 Test클래스는 아니지만 같은 oop동네에 살고있어서 pac필드의 값변경가능
		Test ob2 = new Test();
		ob2.pac = 5;
		ob2.showField();  
	}

}

======================================================================
package oop;

class Student3 {
	
	private String name;
	private int score;
	
	public Student3() {
		System.out.println("기본 생성자");
	}
	
	public void show() {
		System.out.printf("%s의 점수는 %d점입니다\n", name, score);
	}
	
	public String getName() {	// String name에 대한 getter
		return name;
	}
	public void setName(String name) {	// String name에 대한 setter
		this.name = name;
	}
	public int getScore() {		// int score에 대한 getter
		return score;
	}
	public void setScore(int score) {	// int score에 대한 setter
		this.score = score;
	}
}

public class Ex04 {
	public static void main(String[] args) {
		Student3 st = new Student3();
//		st.name = "이지은";	// The field Student3.name is not visible
		st.setName("이지은"); // 전달되는 값이 클래스 내부 메서드안에서 대입을 수행하므로 가능
		
//		st.score = 100;		// 접근제한자 private의 필드에는 외부에서 값을 대입할 수 없다
		st.setScore(100);
		
//		System.out.println("이름 : " + st.name);		// private 필드의 값을 직접 참조할 수 없다
		System.out.println("이름 : " + st.getName());	// getter 메서드를 통해서 참조할 수 있다
		
//		System.out.println("점수 : " + st.score); 	// private 필드의 값을 직접 참조할 수 없다
		System.out.println("점수 : " + st.getScore());// getter 메서드를 통해서 참조할 수 있다
		
		st.show();
		
		
		
		
	}
}
===================================================================
package oop;

import java.util.Scanner;

public class Quiz01 {
	public static void main(String[] args) {
		
		// Ex01 파일의 Studnet 클래스를 활용하여 문제를 풀어보세요 (import는 필요없음)
		// 1) 서로 다른 Student 형태의 객체 3개를 생성하세요
		Student st1 = new Student();
		Student st2 = new Student();
		Student st3 = new Student();
		
		// 2) Scanner 를 활용하여 각각의 객체에 서로 다른 이름과 점수를 입력받으세요
		Scanner sc = new Scanner(System.in);
		
		System.out.print("이름 입력 : ");
		st1.name = sc.nextLine();	// 객체의 멤버 필드도 변수처럼 사용하면 된다
		System.out.print("점수 입력 : ");
		st1.score = Integer.parseInt(sc.nextLine());
		System.out.println();
		
		System.out.print("이름 입력 : ");
		st2.name = sc.nextLine();	// 객체의 멤버 필드도 변수처럼 사용하면 된다
		System.out.print("점수 입력 : ");
		st2.score = Integer.parseInt(sc.nextLine());
		System.out.println();
		
		System.out.print("이름 입력 : ");
		st3.name = sc.nextLine();	// 객체의 멤버 필드도 변수처럼 사용하면 된다
		System.out.print("점수 입력 : ");
		st3.score = Integer.parseInt(sc.nextLine());
		System.out.println();

		
		// 3) Student 형태의 배열(길이: 3)을 생성하세요
		Student[] stuArr = new Student[3];
//		Student[] stuArr = { st1, st2, st3 };	// 선언과 동시에 초기화는 가능
		
		// 4) 객체 3개를 배열에 넣어주세요
//		stuArr = { st1, st2, st3 };	// 멤버를 지정하여 배열을 만들때는 선언시에만 가능
		stuArr = new Student[]{ st1, st2, st3 };
		
		stuArr[0] = st1;
		stuArr[1] = st2;
		stuArr[2] = st3;
		
		// 5) 배열을 대상으로 반복문을 사용하여 각 객체의 show() 함수를 호출하여 결과를 확인하세요
//		for(int i = 0; i < stuArr.length; i++) {
//			Student tmp = stuArr[i];
//			tmp.show();
//		}
		
		for(Student tmp : stuArr) {
			tmp.show();
		}
		
	}
}
===============================================================================
package oop;

import java.util.Scanner;

class Circle {
	double radius;
	final double pi = 3.1415926535;
	double area;
	Scanner sc = new Scanner(System.in);
	
	Circle() {
		System.out.print("반지름을 입력 (실수): ");
		radius = sc.nextDouble();
//		this(radius);	// Constructor call must be the first statement in a constructor
		area = this.radius * this.radius * pi;  
	}
	Circle(int radius) {		// 아래에 double을 매개변수로 가지는 생성자와 코드 진행이 똑같다
//		this.radius = radius;
//		area = this.radius * this.radius * pi;  
		// 이미 만들어져있는 생성자를 호출하는 형태로 변경해보자
		// 생성자 내부에서 또다른 생성자를 호출할 때는 클래스 이름 대신 this 키워드를 사용하여 this() 의 형태로 호출한다
		// 다른 생성자를 호출하는 코드는 생성자 내부에서의 첫 번째 줄에서만 가능하다
		this((double)radius);	// 자료형을 변경하지 않으면, 재귀 무한 반복에 빠진다 (Recursive)
	}
	Circle(double radius) {
		this.radius = radius;
		area = this.radius * this.radius * pi;  
	}
	
	void show() {
		// 원의 반지름 출력
		System.out.printf("반지름 : %.2f㎝ \n", radius);
		// 원의 넓이를 소수점 둘째자리까지 출력하고 한줄 비워놓기
		System.out.printf("넓이 : %.2f㎠ \n\n", area);
	}
}
// 넓이 = 반지름 * 반지름 * 원주율 (㎠)
// 둘레 = 반지름 * 2 * 원주율 (㎝)

public class Quiz03 {
	public static void main(String[] args) {
		Circle c1 = new Circle();		// 생성자 내부에서 Scanner를 활용하여 입력받기
		Circle c2 = new Circle(3);		// 전달하는 정수를 반지름으로 설정
		Circle c3 = new Circle(2.2);	// 전달하는 실수를 반지름으로 설정
		
		c1.show();
		c2.show();
		c3.show();
	}
}
===============================================================================
package reference;

class Ball {
	
}

class Kid {
	String name;
	Ball b;
	
	Kid(String name) {
		this.name = name;
	}
	
	void takeBall(Ball b) {
		this.b = b;
		System.out.println(name + "가 공을 가지고 있다 \n");
	}
	
	void throwBall(Kid other) {
		System.out.println(name + "가" + other.name + "에게 공을 던졌다");
		other.takeBall(b); //여기서 b는 this의 볼이다. 그 볼을 other의 멤버필드에 저장
		this.b = null; //볼을 던졌으니 null
	}
}

public class Ex01 {
	public static void main(String[] args) {
		Kid minho = new Kid("민호");  //takeBall, throwBall 메서드를 가진다
		Kid chan = new Kid("찬혁");	  //takeBall, throwBall 메서드를 가진다
		Ball b = new Ball();
		
		minho.takeBall(b);
		minho.throwBall(chan);
		chan.throwBall(minho);
	}
}
================================================================
package reference;

import java.io.PrintWriter;
import java.util.Scanner;

class Sender { //보내는 사람 (입력받아서 전달만하고, 출력하지 않음)
	Scanner sc = new Scanner(System.in);
	
	void send(Recipient recipient) {
		System.out.print("보낼 메시지를 입력: ");
		String msg = sc.nextLine();
		recipient.receive(msg);
	}
}

class Recipient { //받는 사람(전달받아서 출력만함)
	PrintWriter pw = new PrintWriter(System.out, true); //autoFlush
	
	void receive(String msg) {
		System.out.println("메시지 도착");
		pw.println(msg);
		pw.flush();
	}
}

public class Ex02 {
	public static void main(String[] args) {
		Sender sender = new Sender(); //객체는 생성, 함수는 실행xxx, 가지고만있음
		Recipient recipient = new Recipient();
		sender.send(recipient);
	}

}
====================================================================
package reference;

import java.io.PrintWriter;
import java.util.Scanner;

class ChattingMember {
	Scanner sc = new Scanner(System.in);
	PrintWriter pw = new PrintWriter(System.out, true); //자동으로 그릇을 밀어줘라
	
	String name;
	
	public ChattingMember(String name) { //생성자
		this.name = name;
	}
	
	String send(ChattingMember recipient) {
		System.out.print("(" + this.name + ") 보낼 메시지 입력: ");
		String msg = sc.nextLine();
		recipient.receive(this,msg); //여기서 this는 member1.send(member2)라고하면 member1이다.
		return msg;
	}
	void receive(ChattingMember sender, String msg) { //받은메시지출력
		//System.out.println("메시지 도착!!");
		pw.println("[" + sender.name + "] : " +msg);
		System.out.println("보내는 사람: " +sender.name + ", 받는사람: " + this.name);
		System.out.println();
	}
}

public class Ex03 {
	public static void main(String[] args) {
		ChattingMember member1 = new ChattingMember("이지은");
		ChattingMember member2 = new ChattingMember("강지은");
		
		while(true) {
			String msg1 = member1.send(member2);
			if("종료".equals(msg1)) {
				break;
			}
			String msg2 = member2.send(member1);
			if("종료".equals(msg2)) {
				break;
		}
	}
}
}
====================================================================================
package reference;

import java.io.PrintWriter;
import java.util.Scanner;

class ChattingMember2 {
	private String name;
	private Scanner sc = new Scanner(System.in);
	PrintWriter pw = new PrintWriter(System.out, true);
	public ChattingMember2(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public Message send(ChattingMember2 recipient) {
		System.out.print("입력: ");
		String message = sc.nextLine();
		Message msg = new Message(message, this, recipient); //this는 sender
		if("종료".equals(message)) {
			return msg;
		}
		recipient.receive(msg);
		return msg;
	}
	
	public void receive(Message msg) {
		pw.println("[" + msg.getSender().getName() + "] : " +msg.getMessage());
		System.out.println("보내는 사람: " +msg.getSender().getName() + ", 받는사람: " + this.name);
		System.out.println();
	}
}

class Message {
	Scanner sc = new Scanner(System.in);
	private String message;
	private ChattingMember2 sender;
	private ChattingMember2 recipient;
	
	public Message(String message, ChattingMember2 sender, ChattingMember2 recipient) {
		this.message = message;
		this.sender = sender;
		this.recipient = recipient;
	}  //생성자로 객체만든다. 만든 후 변경하기위해서는 setter가 필요한것이다. 지금은 getter만썻다.
	
	public String getMessage() {
		return message;
	}
	public ChattingMember2 getSender() {
		return sender;  
	}
	public ChattingMember2 getRecipient() {
		return recipient;
	}
}

public class Ex04 {
	public static void main(String[] args) {
		ChattingMember2 member1 = new ChattingMember2("이지은");
		ChattingMember2 member2 = new ChattingMember2("강지은");
		while(true) {
			Message msg1 = member1.send(member2);
			if("종료".equals(msg1.getMessage())) {
				break;
			}
			Message msg2 = member2.send(member1);
			if("종료".equals(msg2.getMessage())) {
				break;
			}
		}
	}
}
==================================================================================
package reference;
import java.util.Scanner;

class Student {        // 내가 프로그램에서 다룰 단일 데이터의 유형을 정의(DTO, VO)
        
        // 학생의 이름, 국어, 영어, 수학, 합계, 평균을 저장할 수 있는 변수를 멤버 필드로 선언
        private String name;
        private int kor, eng, mat, sum;
        private double avg;
        
        // 학생의 생성을 위해 이름을 매개변수로 받는 생성자를 정의 (이름을 전달하지 않으면 객체 생성 불가)
        public Student(String name) {
                this.name = name;
        }

        // 각각의 멤버 필드에 대한 getter/setter 작성
        public String getName() {
                return name;
        }
        public void setName(String name) {
                this.name = name;
        }
        public int getKor() {
                return kor;
        }
        public void setKor(int kor) {
                this.kor = kor;
        }
        public int getEng() {
                return eng;
        }
        public void setEng(int eng) {
                this.eng = eng;
        }
        public int getMat() {
                return mat;
        }
        public void setMat(int mat) {
                this.mat = mat;
        }
        public int getSum() {
                return sum;
        }
        public void setSum(int sum) {
                this.sum = sum;
        }
        public double getAvg() {
                return avg;
        }
        public void setAvg(double avg) {
                this.avg = avg;
        }
        
        // 단일 학생의 정보를 모두 출력하는 메서드 작성 (이름, 모든 점수와 합계, 평균 출력)
        public void showAll() {
                System.out.println("이름 : " + name);
                System.out.println("국어 : " + kor);
                System.out.println("영어 : " + eng);
                System.out.println("수학 : " + mat);
                System.out.println("합계 : " + sum);
                System.out.printf("평균 : %.2f\n", avg);
                System.out.println();
        }
        
        // 단일 학생의 정보를 한 줄에 출력하는 메서드 작성 (이름, 합계, 평균 출력)
        public void showSimple() {
                System.out.printf("%s : %d, %.2f\n", name, sum, avg);
        }
}

class Handler {        // 단일 데이터 여러개를 어떤 자료구조에 저장해둘지, 어떤 기능으로 데이터를 제어할지
        
        private Student[] arr = new Student[10];        // Database
        private Scanner sc = new Scanner(System.in);
        
        // 학생 추가 기능                                        DAO의 역할
        public Student addStudent() {
                String name;
                int kor, eng, mat;
                
                System.out.print("학생의 이름 입력 : ");
                name = sc.nextLine();
                Student st = new Student(name);
                System.out.print("국어 점수 입력 : ");
                kor = Integer.parseInt(sc.nextLine());
                st.setKor(kor);
                
                System.out.print("영어 점수 입력 : ");
                eng = Integer.parseInt(sc.nextLine());
                st.setKor(eng);
                
                System.out.print("수학 점수 입력 : ");
                mat = Integer.parseInt(sc.nextLine());
                st.setKor(mat);
                
                st.setSum(kor + eng + mat);
//                st.setAvg((kor + eng + mat) / 3.0);
                st.setAvg(st.getSum() / 3.0);
                
                for(int i = 0; i < arr.length; i++) {
                        if(arr[i] == null) {
                                arr[i] = st;
                                break;
                        }
                }
                
                return st;
        }
        // 학생 목록 출력 기능
        // 상세 학생 출력 기능
        // 정렬 기능(평균 기준 내림차순 정렬)
}

public class Quiz02 {        // 사용자와 상호작용하는 프로그램의 표면 계층 (Web Browser)
        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                // 프로그램이 사용자와 상호작용 할 수 있는 사용자 인터페이스 구현
                // 메뉴를 숫자로 입력받고, 입력받은 메뉴에 따라 handler의 기능을 호출하는 형태로 작성
                // while, switch ~ case 사용
                sc.close();
        }
}
=================================================================
package sort;

public class Ex01 {
	static void printArray(int[] arr) {
		for(int i=0; i<arr.length; i++) {
			int num = arr[i];
			System.out.print(num + " ");
		}
		System.out.println();
	}
	public static void main(String[] args) {
		int[] arr = {2,7,4,8,6};
		printArray(arr);
		int tmp;
		//arr배열을 정렬하는 코드(오름차순)-> 아래코드는 선택정렬이다.
		for(int i = 0; i<arr.length-1; i++) { // 0 1 2 3
			for(int j = i+1; j<arr.length; j++) { // 0) 1 2 3 4 0이기준이면 1 2 3 4 를비교
				                                  // 1) 2, 3 4
				                                  // 2) 3, 4
				                                  // 3) 4
				if(arr[i] > arr[j]) {
					tmp = arr[i];
					arr[i]=arr[j];
					arr[j]=tmp;
				}
			}
		}
		printArray(arr);
	}
}

=========================================================================================
package sort;

public class Ex02 {
	static void showArr(String[] arr) {
		for(int i = 0; i<arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}
	
	static void sort(String[] arr) { //배열만 전달하여 오름차순으로 정렬
		sort(arr,false);
	}
	static void sort(String[] arr, boolean desc) { //배열과 boolean을 전달하면 true일때 내림차순정렬
		for(int i = 0; i<arr.length; i++) {
			for(int j=i; j<arr.length; i++) {
				if(arr[i].compareTo(arr[j]) > 0) {
					String tmp = arr[i];
					arr[i] = arr[j];
					arr[j] = tmp;
				}
			}
		}
	}
	
	public static void main(String[] args) {
		String data = "짱구, 훈이, 철수, 유리, 맹구, 흰둥이";
		String[] arr = data.split(", ");
	
		//앞에가 작으면 음수 (작은게 앞으로)
		System.out.println(arr[0].compareTo(arr[1])); //짱구vs훈이 -> -3287
		System.out.println(arr[1].compareTo(arr[2])); //훈이 vs철수 -> +2600
	
		showArr(arr);
		long startTime = System.nanoTime(); //함수호출전 시간
		sort(arr);
		long endTime = System.nanoTime(); //호출 후 시간
		//맹구 유리 짱구 철수 훈이 흰둥이 로 정렬된다.(내림차순)
		showArr(arr);
		System.out.println("정렬 소요시간: " +(endTime = startTime)+ "ns");
	}

}
==============================================================================
package sort;

public class Fac {
	
	static int factorial(int n) {
		if(n==1) {
			return n;
		}
		return n * factorial(n-1);
	}
	
	public static void main(String[] args) {
		System.out.println(factorial(4));

	}
	
}
===================================================================================
package sort;

import java.io.File;
import java.util.Scanner;

public class Quiz01 {

	static void showArr(String[] arr) {
		for(int i = 0; i<arr.length; i++) {
			System.out.printf("%s\t", arr[i]);
			System.out.print((i+1) % 5 == 0 ? "\n" : " ");
		}
		System.out.println("================구분선");
	}
	
	public static void main(String[] args) throws Exception{
		File f = new File("한국배우목록.txt");
		Scanner sc = new Scanner(System.in);
		String data ="";

		while(sc.hasNextLine()) {
			String name = sc.nextLine();
			data += name;
			data += ", ";
		}
		
		String[] arr=  data.split(", ");
		showArr(arr);
		
		//정렬하는 코드를 함수로 만들어서 호출
		long startTime = System.nanoTime();
		String[] arr1 = selectionSort(arr);
		long endTime = System.nanoTime();
		
		showArr(arr1);
		System.out.printf("선택정렬에 걸린시간 : %.2fsec\n" + (endTime - startTime)/ 1000000000.0); //나노초
		sc.close();
	}

	static String[] selectionSort(String[] arr) {
		String[] newArr = arr.clone();
		
		for(int i = 0; i<newArr.length; i++) {
			for(int j = i+1; j<newArr.length; j++) {
				if(newArr[i].compareTo(newArr[j]) > 0) { 
					String tmp = newArr[i];
					newArr[i] = newArr[j];
					newArr[j] = tmp;
				}
			}
		}
		return newArr;
	}

}
=================================================================
package inheritance;

class Super {
	int n1 =0;
	public Super() {
		System.out.println("슈퍼클래스 생성자 호출");
	}
}

class Sub extends Super {
	int n2 =1;
	public Sub() {
		//super();
		System.out.println("서브 클래스 생성자 호출");
	}
}

public class Ex07 {

	public static void main(String[] args) {
		//1. Sub class를 찾아가고 보니까 상속받았네? 그러면 Super로가서 super객체를 메모리에 만든다.
		//2. 다시 Sub class로 가서 만든다. 
		Sub ob1 = new Sub(); //슈퍼생성자먼저 출력후 서브생성자 호출된다.
		System.out.println(ob1.n1);
		System.out.println(ob1.n2);
	}

}

==========================================================================
package inheritance;

import java.util.Scanner;

class Student {
	int kor, eng, mat, sum;
	double avg;
	Student() {};
	
	public void show() {
		sum = kor+eng+mat;
		double avg = sum/3.0;
		System.out.println("합계 : " + sum);
		System.out.printf("평균: %.2f" + avg);
	}
}

class Student2 extends Student {
	int rus;
	@Override
	public void show() {
		sum = kor+eng+mat+rus; //sum,kor,eng,mat는 상속받아서 따로 선언xxx
		double avg = sum/4.0;
		System.out.println("합계 : " + sum);
		System.out.printf("평균: %.2f" + avg);
	}
}

public class Quiz01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		Student st1 = new Student();
		Student2 st2 = new Student2();
		Student[] arr = {st1, st2}; //student로 묶을 수 있다
		System.out.println("학생1");
		System.out.print("국어 점수입력: ");
		st1.kor = sc.nextInt();
		System.out.print("영어 점수입력: ");
		st1.eng = sc.nextInt();
		System.out.print("수학 점수입력: ");
		st1.mat = sc.nextInt();
		
		System.out.println("학생2");
		System.out.print("국어 점수입력: ");
		st2.kor = sc.nextInt();
		System.out.print("영어 점수입력: ");
		st2.eng = sc.nextInt();
		System.out.print("수학 점수입력: ");
		st2.mat = sc.nextInt();
		System.out.print("러시아어 점수입력: ");
		st2.rus = sc.nextInt();
		
		for(Student st : arr) {
			st.show(); //show()메서드가 오버라이딩되었다면, 재정의된 함수를 찾아간다.
		}
	}
}
==================================================================
package sort;

import java.util.Random;

public class Ex01 {
	static void showArr(int[] arr) {
		for(int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + ((i == arr.length - 1) ? "\n" : " "));
		}
	}
	//배열합치기
	static int[] slice(int[] arr, int startIndex, int endIndex) {
		int[] tmp = new int[endIndex - startIndex];
		for(int i = 0; i < tmp.length; i++) {
			tmp[i] = arr[i + startIndex];
		}
		return tmp;
	}
	//배열자르기
	static int[] sum(int[] arr1, int[] arr2) {
		int[] tmp = new int[arr1.length + arr2.length];
		
		for(int i = 0; i < arr1.length; i++) {	// 0, 1, 2, 3, 4
			tmp[i] = arr1[i];
		}
		for(int i = arr1.length; i < tmp.length; i++) {	// 5, 6, 7, 8, 9
			tmp[i] = arr2[i - arr1.length];
		}
		return tmp;
	}
	static int[] generateRandomArray(int length) {
		int[] arr = new int[length];
		Random ran = new Random();
		for(int i=0; i<arr.length; i++) {
			arr[i] = ran.nextInt(length); // 0~10까지 숫자
		}
		
		return arr;
	}
	
	static int[] merge_sort(int[] arr) {
		if(arr.length==1) {
			return arr;
		}
		
		int mid = arr.length / 2; //절반위치
		int[] g1 = merge_sort(slice(arr,0,mid));
		int[] g2 = merge_sort(slice(arr,mid,arr.length));
		
		int[] result = new int[0];
		
		//둘다 배열의요소가있을때
		while(g1.length != 0 && g2.length != 0) {
			if(g1[0] < g2[0]) {
				result = sum(result,new int[] {g1[0]}); //g1을 먼저 result에 넣어라
				g1 = slice(g1,1,g1.length);
			}
			else {
				result = sum(result, new int[] {g2[0]});
				g2=slice(g2,1,g2.length);
			}
		}
		while(g1.length != 0) sum(result,g1);
		while(g2.length != 0) sum(result,g2);
		
		return arr;
	}
	
	public static void main(String[] args) {
		int[] arr = generateRandomArray(10);
		showArr(arr);
	}
}

=============================================================================
package sort;

class Member {
	//static : 멤버요소가 클래스에 속하기 때문에, 객체를 생성하지 않아도 접근이 가능하다
	//객체마다 다른값을 가지지않고, 자료형에 속하는 하나의 값으로써 각각의 객체가 공유할수 있는 값이된다.
	String name;
	int age;
	static int all; //클래스가 메모리에 로드되는 시점에서 생성된다.(객체 생성이전에 이미 생성되어있다)
	
	
	Member(String name, int age) {
		this.name = name;
		this.age = age;
		System.out.println(name + "객체 생성!!");
		all += 1;
	}
	void showInfo() {
		System.out.printf("%s의 나이는 %d살입니다\n", name, age);
	}
	static void showAllCount() {
		System.out.println("all: " + all);
	}
}

public class Ex02 {

	public static void main(String[] args) {
		//클래스 생성안해도 바로 all접근가능
		System.out.println(Member.all);
		Member m1 = new Member("이지은",29);
		Member m2 = new Member("홍진호",40);
		m1.showInfo();
		m2.showInfo();
		
		//static한 방식으로 접근해라고 경고만나온다.(실행은됌)
		//static요소와 non-static요소의 생성시점에 대한 관계
		
//		1. static 요소는 객체가 아닌 클래스에 클래스에 소속된다.
//      2. 클래스가 객체보다 먼저 메모리에 로드된다.
//      3. 클래스에 소속된 static요소가 객체에 소속되는 non-static요소보다 먼저 메모리에 로드된다,
//      4. 따라서 static 요소는 언제든지 non-static요소를 참조할 수 없다(상황에따라서)
//	    5. non-static요소는 언저든지 static 요소를 참조할 수 있다.
//	    6. main함수는 객체 생성 이전에 호출할 수 있어야 하므로, 항상 static으로 정의한다.
//      7. 따라서 static이 먼저생성되고, non-static은 나중에생긴다.
		m1.showAllCount(); //2 -> 클래스로 접근하는게 좋다.(이거보다) meber.showAllCount
		m2.showAllCount(); //2
		
		m1.all += 1;
		m2.showAllCount(); //3
		Member.showAllCount();
		
		//객체는 서로 다르지만 클래스는 같다.
		System.out.println(m1.getClass());
		System.out.println(m2.getClass());
		
		
	}

}
==============================================================================
package sort;

class Pos2D {
	int x,y;
	
	public void setPos(int x, int y) {
		this.x = x;
		this.y = y;
	}
	
	public void showPos() {
		System.out.println("x : " + x + ", y : " + y);
	}
}

class Test extends Pos2D {
	//상속만 받았을 뿐 직접작성한 내용은 없다.
	//단순히 복사만 할꺼라면 그냥 Pos2D객체를 만들면된다. -> import
}

class Pos3D extends Pos2D {
	//기존의 클래스의 기능을 물려받은 이후, 추가적인 요소를 작성하여 나만의 클래스로 새롭게 정의한다
	int z; //int x, int y가 존재한다.
	
	void setPos3D(int x, int y, int z) {
		this.x =x; // 상위 클래스(Pos2D)가 가지는 함수이름과 중복되는 내용이 없으니 새로작성가능(함수이름이달라서)
		this.y =y;
		this.z =z;
	}
	
	//상위클래스가 가지는 함수와 똑같은 이름, 똑같은 매개변수형식을 지정하면, 기존의 함수의 내용을 덮어쓴다.
	//즉 오버라이딩이다.
	public void showPos() {
		System.out.println("x : " + x + "y : " + y + "z : "+z);
	}
}
class Human {
	String name;
}
class Student extends Human {
	
}

public class Ex03 {
	public static void main(String[] args) {
		Pos2D ob1 = new Pos2D();
		ob1.setPos(2,3);
		ob1.showPos();
		
		Test ob2 = new Test();
		ob2.setPos(4, 7);
		ob2.showPos();
		
		Pos3D ob3 = new Pos3D();
		ob3.setPos3D(2, 3,4); //pos2D에 없는 Pos3D만의 고유기능
		ob3.showPos();
	
		//사람클래스를 상속받아서, 학생 클래스를 만든다면
		//학생은 사람의 특징을 그대로 가지고있기 때문에
		//학생도 사람으로 볼수있다
		Human ob4 = new Human();
		ob4.name ="이지은";
		
		Student ob5 = new Student();
		ob5.name = "홍진호";
		
		Human[] arr = {ob4,ob5}; //배열은 같은 자료형의 데이터
		for(Human h : arr) {
			System.out.println(h.name);
		}
	}
}
===================================================================
package sort;

class People { //super class, 상위클래스, 부모클래스
	String name;
	int age;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	public void show() {
		System.out.println("이름: " + name);
		System.out.println("나이: " + age);
		System.out.println();
	}
	
}

class Member1 extends People { //sub class, 하위, 자식  //자식은 부모의 메서드, 변수를 참조할 수 있다
	String id;
	String password;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	
	@Override //이 메서드는 슈퍼클래스로부터 상속받아서 재정의하는 메서드다.
	public void show() { //부모에서 public으로 했으면 좁힐수없다. 넓힐수는있다. 즉 private할수없다.
		System.out.println("이름: " + name); //부모가 People이라서 가져올수있다. private라면 get으로가져와야댐
		System.out.println("나이: " + age);
		System.out.println("ID: " + id);
		System.out.println("password: " + password);
	}
	//public void show(int num) 이렇게하면 오버로딩이된다. 하나의 메서드가 따로 생성
}

public class Ex05 {
	public static void main(String[] args) {
		//Member1class가 가지는 메서드는 9개다.
		
		People ob1 = new People();
		//ob1.id = "iiii" People에 id라는 멤버필드가 없어서 안된다.
		ob1.name = "이지은";
		ob1.age = 29;
		ob1.show();
		
		Member1 ob2 = new Member1();
		ob2.name ="홍진호";
		ob2.age = 40;
		ob2.id = "Yellow";
		ob2.password ="zerg";
		ob2.show();
	
		System.out.println("----------------");
		People[] arr = {ob1,ob2};
		for(People p : arr) {
			p.show(); //메서드는 오버라이딩된게 있으면 자식으로 알아서 찾아간다.
		}
	}
	
}
==========================================================================
package inheritance;

class Pos2D {
	int x,y;
	
	public Pos2D(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

class Pos3D extends Pos2D{
	int z;	
	Pos3D(int x, int y, int z) {
			super(x,y); //super클래스에서 처리한다.
			this.z = z;
		}
	public void show() {
		System.out.println("x : " + x + " y : " + y + " z : " + z);
	}
}

public class Ex02 {
	public static void main(String[] args) {
		Pos3D ob1 = new Pos3D(2,3,4);
		ob1.show();
	}
}
===========================================================================
package inheritance;

class C /*extends Object*/{
	
	//Object에서 상속받아서 메서드를 가지고 있다면 오버라이딩이 가능하다.
	public String toString() {
		//return super.toString();
		return "내가 오버라이딩 한 메서드의 반환값";
	}

}

class D extends C {
	//상속을 지정했고, 자바에서는 단일 상속만 가능하므로, 직접 Object를 상속하지는 않는다.
	//그러나, C class가 이미 Object 내용을 이미 다 상송받았으므로, D도 C를 통해서 Object의 내용을 가지게된다.
	
	@Override
	public String toString() {
		return "D";
	}
}

public class Ex03 {
	public static void main(String[] args) {
		C ob1 = new C();
		
		//원래 ob1에는 메서드가없다.... 근데,
		//ob1에는 원래는 아무내용이 없는데도 불구하고 객체의 메서드가 호출된다? -> object가 가지고있는 메서드라 가능
		System.out.println(ob1.hashCode());
		System.out.println(ob1.toString()); //출력: 내가 오버라이딩 한 메서드의 반환값
		System.out.println(ob1.getClass());
		
		D ob2 = new D();
		System.out.println(ob2); //D로 출력결과  //자동으로 오버라이딩된 메서드를 찾아간다
		
	}
}
==========================================================================
package inheritance;

class Human /*extends Object*/ {
	String name;
	int age;
	
	public Human(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	//getter로 일일이 출력하는게 아니라 바로 이렇게 toString을 오버라이딩하는경우가많다.
	@Override
	public String toString() {
		return String.format("이름: %s, 나이: %d\n", name,age);
	}
}

public class Ex04 {
	public static void main(String[] args) {
		Human ob1 = new Human("이지은",29);
		Human ob2 = new Human("홍진호",40);
		System.out.println(ob1); //이름 : 이지은 29, 나이: 29
		System.out.println(ob2);
	}
}
==========================================================================
package quiz;

import java.util.Scanner;

//Handler는 학생저장, 수정, 검색 등 기능이 들어있다.
class Student { //각 클래스가 공통으로 가지는 속성과 기능을 슈퍼클래스에 정의하기
	//private을 적용하면 서브클래스도 데이터에 접근xx
	//protected를 적용하면 상속관계에 있는 클래스에서 접근할 수 있다.
	String name;
	int kor, eng, mat, sum;
	double avg;
	
	public Student(String name, int kor, int eng, int mat) {
		this.name = name;
		this.kor = kor;
		this.eng = eng;
		this.mat = mat;
		this.sum = kor+eng+mat;
		this.avg = sum/3.0;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
	public int getKor() {
		return kor;
	}
	public void setKor(int kor) {
		this.kor = kor;
	}
	public int getEng() {
		return eng;
	}
	public void setEng(int eng) {
		this.eng = eng;
	}
	public int getMat() {
		return mat;
	}
	public void setMat(int mat) {
		this.mat = mat;
	}
	public int getSum() {
		return sum;
	}
	public void setSum(int sum) {
		this.sum = sum;
	}
	public double getAvg() {
		return avg;
	}
	public void setAvg(double avg) {
		this.avg = avg;
	}
	
	public void show() {} //st.show()로 호출하면 자식으로 내려가기 위해서 생성만했다.
}

class LiberalArtsStudent extends Student {
	int deu;
	public LiberalArtsStudent(String name, int kor, int eng, int mat,int deu) {
		super(name, kor, eng, mat);
		this.deu = deu;
		this.sum += deu; //부모에서 이미 sum을실행했고 여기서 독일어만추가
		this.avg = sum/4.0;
	}
	
	//간단 출력
	@Override
	public String toString() {
		return String.format("이름: %s, 국어국문, 평균: %.2f", name, avg);
	}
	//상세 출력
	public void show() {
		System.out.printf("국어국문과%s", name);
		System.out.println("국어 : "+kor);
		System.out.println("영어: "+eng);
		System.out.println("수학: "+mat);
		System.out.println("제2 외국어: "+deu);
		System.out.println("합계 : "+sum);
		System.out.printf("평균: %.2f\n", avg);
		System.out.println();
	}
	public int getDeu() {
		return deu;
	}
	public void setDeu(int deu) {
		this.deu = deu;
	}
	
}

class ComputerEngineeringStudent extends Student {
	int java, clang;
	
	public ComputerEngineeringStudent(String name, int kor, int eng, int mat,int java, int clang) {
		super(name, kor, eng, mat);
		this.clang = clang;
		this.java = java;
		this.sum += clang +java;
		this.avg = sum / 5.0;
		
	}
	//간단 출력
		@Override
		public String toString() {
			return String.format("이름: %s, 컴퓨터공학, 평균: %.2f", name, avg);
		}
		//상세 출력
		public void show() {
			System.out.printf("컴퓨터공학과%s", name);
			System.out.println("국어 : "+kor);
			System.out.println("영어: "+eng);
			System.out.println("수학: "+mat);
			System.out.println("C언어: "+clang);
			System.out.println("Java: "+java);
			System.out.println("합계 : "+sum);
			System.out.printf("평균: %.2f\n", avg);
			System.out.println();
		}
}

class Handler {
	static Student[] arr = new Student[50];
	
	private Handler() {
		
	}
	//목록
	public static void showList() {
		for(Student st:arr) {
			if(st != null) {
				System.out.println(st);
			}
		}
	}
	//검색(Student반환)
	public static Student search(String name) {
		for(Student st : arr) {
			if(st!=null && st.getName().equals(name)) {
				return st;
			}
		}
		return null;
	}
	//추가(메인함수에서 객체생성없이 만들기위해 static, switch2번에서)
	public static int insert(Student st) {
		for(int i = 0; i<arr.length; i++ ) {
			if(arr[i] == null) {
				arr[i] =st;
				return 1;
			}
		}
		return 0;
	}
	
	//삭제
	public static int delete(String name) {
		for(int i = 0; i<arr.length; i++) {
			if(arr[i]!=null && arr[i].getName().equals(name)) {
				arr[i]=null;
				return 1;
			}
		}
		return 0;
	}
}

public class Quiz01 {
	public static void main(String[] args) {
		//1)학생 객체를 생성할 수 있도록 Student클래스를 준비(국영수)
		//2)학생 객체에 대한 생성, 목록, 검색, 수정, 삭제를 처리할 수 있도록 Handler클래스
		//3)main 함수에서는 Handler의 객체를 생성하여 while, switch~case로 입출력제어
		//4)Student 클래스를 상속받는 LiberalArtsStudent(어문학과)를 작성하고 추가과목으로 제2외국어만드세요
		//5)Student 클래스를 상속받는 ComputerEngineeringStudent 작성하고 추가과목으로 C,Java만드세요
		//6)모든 학생을 저장할 수 있는 배열 Student[] arr 를 Handler클래스 내부에 static형식으로 작성
		//7)Handler의 필드나 메서드는 static으로 설정하여 객체 생성없이 제어할수 있도록 처리
		//8)toString() 메서드를 오버라이딩하여 학생이름, 전공, 평균이 출력
		//9)상세한 내용을 모두 출력하는 메서드 show()를 작성 (각 이름, 과목점수,합계, 평균)
		
		Scanner sc = new Scanner(System.in);
		System.out.println("\t학생 관리 프로그램(ver0.2)\n\n");
		String menuList = "\n1. 추가 | " 
				+ "2. 목록 | "
				+ "3. 검색 | "
				+ "4. 수정 | "
				+ "5. 삭제 | "
				+ "0. 종료 | "
				+ "메뉴 선택>>> ";
		
		int menu = 0, type;
		int kor, eng, mat, deu, clang, java, result;
		String name;
		Student st = null;
		do {
			System.out.print(menuList);
			menu = Integer.parseInt(sc.nextLine());
			switch(menu) {
				case 1:   //추가
					System.out.println("전공을 선택하세요");
					System.out.println("1) 국어국문");
					System.out.println("2) 컴퓨터공학");
					System.out.print("전공선택 >>>");
					type = Integer.parseInt(sc.nextLine());
					
					System.out.print("이름입력: "); name = sc.nextLine();
					System.out.print("국어입력: "); kor = Integer.parseInt(sc.nextLine());
					System.out.print("영어입력: "); eng = Integer.parseInt(sc.nextLine());
					System.out.print("수학입력: "); mat = Integer.parseInt(sc.nextLine());
					break;
				case 2:  //목록
					break;
				case 3: //검색
					break; 
				case 4:  // 수정(안함)
					break;
				case 5: //삭제
					break;
			}
		}while(menu != 0);
	}

}
=========================================================================================
package day16;

//인터페이스 : 추상클래스의 한 종류이면서, 일반 메서드를 포함할 수 없는 형태
//1) 모든 필드는 static final 속성을 갖는다
//2) 모든 메서드는 public abstract 속성을 갖는다. 그래서 인터페이스는 추상메서드만 포함할수있다.
//3) extends 대신 implments(구현) 키워드로 상속을 처리한다.
//4) 다중상속이 허용되는 형태

//일반 클래스 : 추상 메서드를 포함할 수 없다.
//추상 클래스 : 일반 메서드도 포함할 수 있고, 추상메서드도 포함할 수 있다.
//인터페이스 : 일반 메서드는 포함할 수 없고, 추상메서드만 포함할 수 있다.

interface CouldSayHello { 
	/*static final*/String PROPERTY = "인사";
	//final필드로 초기화된다(자동으로 interface라서)
	
	//추상 메서드는 몸체를 구체적으로 명시할 수 없다.
	/*public abstract*/void hello();
}

//클래스는 따로 상속받을 수 있고 인터페이스는 (,)콤마로 여러개 가져올수있다.
//따라서 여러 인터페이스를 하나의 클래스에 몰아넣을 수 있다.
class Student2 extends Object implements CouldSayHello {
	//반드시 hello를 재정의 해야한다.
	String name;
	
	public Student2(String name) {
		this.name = name;
	}
	
	@Override
	public void hello() {
		System.out.println(name + " : 안녕하세요");
	}
	
}

public class Ex02 {
	//3가지방법
	public static void main(String[] args) {
		System.out.println(CouldSayHello.PROPERTY);
		//1)상속(implements)형태로 활용
		Student2 ob1 = new Student2("이지은");
		ob1.hello();
		//2)인터페이스도 큰 관점에서 보면 추상클래스이기 때문에 익명클래스를 활용
		//CouldSayHello를 상속받은 이름없는 클래스다.
		//그래서 탐색기에서 class파일을 보면 Ex02$1 로 이름없는 클래스파일이 만들어진다.
		CouldSayHello ob2 = new CouldSayHello() {
			//생성자는 못만든다. 익명(이름이없는 클래스라)
			@Override
			public void hello() {
				System.out.println("일병  안준호");
			}
		};
		ob2.hello();
		
		//3) 인터페이스가 오로지 하나의 추상 메서드만 포함하는 경우, java 1.8부터 지원되는 람다식 객체생성을 활용
		//CouldSayHello가 함수가 하나만 가진다면
		//함수가 매개변수를 받는다면 매개변수 넣으면 된다.
		CouldSayHello ob3 = () -> System.out.println("부산행 열차 탑승");  //hello라는 함수가 하나니까 람다식으로 표현가능 -> 함수 몸체정의 가능
		//()는 함수를 상징하며, 매개변수 형태를 작성할 수있다.
		//하나의 미구현 메서드의 내용만 만들어주면 객체를 생성할 수 있으므로, 화살표 뒤에 함수의 내용을 작서하면된다.
		//여러줄의 내용을 작성하려면 {}를 이용하여 body블럭을 만들 수 있다.
		ob3.hello();
		
		CouldSayHello ob4 = () -> {
			System.out.println("안녕하십니까");
			System.out.println("전 메이저리거 박찬호");
			System.out.println("제가 LA에 있을 때에는");
		};
		ob4.hello();
	}
}
==================================================================================
package day16;

class PC {
	void connect(USB ob) {
		ob.react(); //usb를 매개변수로 받아서 usb에 있는 react라는 함수를 호출
	}
}

//implements로 하면 무조건 함수 재정의 해야한다.
//USB로 묶을수있다(공통으로 usb를 implements했기때문에). 그래서 PC클래스에서 USB매개변수로 받는다.
class DataCable implements USB {
	@Override //오버라이딩은 슈퍼클래스에서 지정한 접근제한자보다 범위를 좁힐 수 없다.
			  //interface는 public이 붙는다(자동으로) 그래서 좁힐수 없다.
	public void react() {
		System.out.println("데이터 전송이 준비");
	}
	
}
class ExternalHDD implements USB{
	@Override
	public void react() {
		System.out.println("외부저장장치가 연결");
	}
	
}
class EletricFan implements USB{
	@Override
	public void react() {
		System.out.println("전원 충전중 ");
	}
	
}

interface USB {
	void react();
}
public class Quiz01 {

	public static void main(String[] args) {
		PC pc = new PC();
		DataCable ob1 = new DataCable();
		ExternalHDD ob2 = new ExternalHDD();
		EletricFan ob3 = new EletricFan();
		
		pc.connect(ob1);        // "데이터 전송이 준비되었습니다"
        pc.connect(ob2);        // "외부 저장장치가 연결되었습니다"
        pc.connect(ob3);        // "전원 충전 중..."
        
        pc.connect( () -> System.out.println("마우스 연결됌") );
        // pc에 장치를 connect하면, 서로 다른 반응이 나타나야 한다
	}
}
===============================================================
package summary;

public class Animal {
	String name;
	
	Animal(String name) {
		this.name = name;
	}
	void bark() {
		System.out.println("...");
	}
}
--------------
package summary;

public class Cat extends Animal {
	Cat(String name) {
		super(name);
	}
}
-----------------
package summary;

public class Dog extends Animal{
	Dog(String name) {
		super(name);
	}
}
-----------------
package summary;

public class Human {
	String name;
	Human(String name) {
		this.name = name;
	}
	void give(Cat c) {
		System.out.println(name + "이" + c.name + "에게 먹이를 주었다");
	}
	void give(Dog d) {
		System.out.println(name + "이" + d.name + "에게 먹이를 주었다");
	}
}
-------------------
package summary;

public class Main {

	public static void main(String[] args) {
		Human h1 = new Human("이제훈");
		Cat c1 = new Cat("구름");
		Dog d1 = new Dog("댕댕이");
		
		h1.give(c1);  //이제훈이 구름에게 먹이를 주었다
		h1.give(d1);  //이제훈이 댕댕이에게 먹이를 주었다

		//메서드 오버로딩을 활용하여 구현
		
	}
}
====================================================================
package summary2;

public class Animal {
	String name;
	
	Animal(String name) {
		this.name = name;
	}
	void bark() {
		System.out.println("...");
	}
}
-----------------
package summary2;

public class Cat extends Animal {
	Cat(String name) {
		super(name);
	}
	//Animal의 메서드 bark()를 오버라이딩해서 [이름 : 야옹] 형식으로 
	@Override
	void bark() {
		System.out.println(name + " : 야용");
	}
}
-----------------
package summary2;

public class Dog extends Animal{
	Dog(String name) {
		super(name);
	}
	//Animal의 메서드 bark()를 오버라이딩해서 [이름 : 멍멍] 형식으
	@Override
	void bark() {
		System.out.println(name + ": 멍멍");
	}
}
----------------
package summary2;

public class Human {
	String name;
	Human(String name) {
		this.name = name;
	}
	//give를 하나의 메서드로 처리할수 있도록
	
	//Animal에서 private String name으로 변수설정하면 a.name으로 못가져온다.
	void give(Animal a) {
		System.out.println(name + "이 " + a.name + "에게 먹이를 주었다");
		a.bark(); //슈퍼클래스 Animal에 메서드가 정의되어있으므로, 호출 할 수 있다
	}
	//자식의 클래스의 객체도 부모클래스 타입으로 참조가 가능하다.
	//하나의 객체가 상황에 따라 슈퍼클래스도 참조할 수 있고, 서브 클래스로도 참조될수 있다.
	// ㄴ> 다형성(Polymorphism)
	
}
------------------
package summary2;

public class Main {

	public static void main(String[] args) {
		Human h1 = new Human("이제훈");
		Cat c1 = new Cat("구름");
		Dog d1 = new Dog("댕댕이");
		
		h1.give(c1);  //이제훈이 구름에게 먹이를 주었다
		h1.give(d1);  //이제훈이 댕댕이에게 먹이를 주었다
		
		c1.bark();
		d1.bark();
		//메서드 오버로딩을 활용하여 구현
		
	}

}
============================================================
package summary3;

public class Animal {
	String name;
	
	Animal(String name) {
		this.name = name;
	}
	void bark() {
		System.out.println("...");
	}
}
----------------
package summary3;

public class Cat extends Animal {
	Cat(String name) {
		super(name);
	}
	@Override
	void bark() {
		System.out.println(name + " : 야용");
	}
}
------------------
package summary3;

public class Dog extends Animal{
	Dog(String name) {
		super(name);
	}
	@Override
	void bark() {
		System.out.println(name + ": 멍멍");
	}
}

--------------------
package summary3;

public class Human {
	String name;
	Human(String name) {
		this.name = name;
	}
	
	void give(Animal a) { //다형성 ->자연스레 업캐스팅됨
		String feed;
		if(a instanceof Cat)
			feed = "츄르";
		else if(a instanceof Dog) 
			feed = "사료";
		else
			feed = "먹이";
		System.out.println(name + "이 " + a.name + "에게" + feed + "를 주었다");
		a.bark(); 
	}
	
}

--------------------------
package summary3;

public class Main {

	public static void main(String[] args) {
		Human h1 = new Human("이제훈");
		Cat c1 = new Cat("구름");
		Dog d1 = new Dog("댕댕이");
		
		h1.give(c1);  //이제훈이 구름에게 츄르를 주었다
		h1.give(d1);  //이제훈이 댕댕이에게 사료를 주었다
		
		//자식 클래스의 객체가 부모클래스의 자료형으로 참조되는 형태를 up-casting이라한다.
		Animal a1 = c1; 
		
		System.out.println(a1); //같다
		System.out.println(c1); //같다 (같은 걸 바라본다)
		
		//up-casting 된 객체를 다시 원래의 자식클래스로 되돌리는 형태를 down-casting
		//Cat c2 = a1; //모든 동물은 고양이가 될수있다(xxx)
		
		//가능
		//Cat c2 = (Cat)a1; //명시적 형변환, 강제형변환해야 down-casting할수있다
		
		if(a1 instanceof Cat) {
			Cat c2 = (Cat)a1;
			c2.bark();
		}
		if(a1 instanceof Cat) {
			Dog d2 = (Dog)a1;
			d2.bark();
		}
	}

}

============================================================================
package summary4;

public class Animal {
	String name;
	
	Animal(String name) {
		this.name = name;
	}
	void bark() {
		System.out.println("...");
	}
	public String getName() { //오버라이딩을 위한 선언
		// TODO Auto-generated method stub
		return null;
	}
}
----------------
package summary4;

public class Cat extends Animal implements Companion{
	Cat(String name) {
		super(name);
	}
	@Override
	void bark() {
		System.out.println(name + " : 야용");
	}
	@Override
	public String getName() {
		return name;
	}
}

---------------------
package summary4;

//대상 클래스의 슈퍼클래스나 상속 여부에 상관없이 항상 인터페이스를 구현할 수 있다.


public interface Companion {
	//String name = "강동원"; //인터페이스 필드는 static final이다.
	
	String getName(); //함수만 선언, 몸체는 implements 한곳에서 정의
}

-------------------------
package summary4;

public class Dog extends Animal implements Companion{
	Dog(String name) {
		super(name);
	}
	@Override
	void bark() {
		System.out.println(name + ": 멍멍");
	}
	@Override
	public String getName() {
		return name;
	}
}

-------------------------
package summary4;

public class Friend extends Human implements Companion{
	Friend(String name) {
		super(name);
	}
}

----------------------------
package summary4;

public class Human {
	String name;
	Human(String name) {
		this.name = name;
	}
	
	//void give(Object a) 가 안되는이유는 하위클래스의 필드나 메서드가 선언되지
	//않은 너무 먼 슈퍼클래스는 부적합하다.
	//자바는 단일상속만가능 , 2단계 슈퍼클래스를 띄어갈수없다. -> 그래서 인터페이스사용
	
	void give(Companion a) { 
		String feed;
		if(a instanceof Cat)
			feed = "츄르";
		else if(a instanceof Dog) 
			feed = "사료";
		else if(a instanceof Friend)
			feed = "과자";
		else
			feed = "먹이";
		System.out.println(name + "이 " + a.getName() + "에게" + feed + "를 주었다");
		//a.bark(); 
	}
	
}
-----------------------------
package summary4;

public class Main {

	public static void main(String[] args) {
		Human h1 = new Human("이제훈");
		Cat c1 = new Cat("구름");
		Dog d1 = new Dog("댕댕이");
		Friend f1 = new Friend("강동원");
		
		h1.give(c1);  //이제훈이 구름에게 츄르를 주었다
		h1.give(d1);  //이제훈이 댕댕이에게 사료를 주었다
		
		h1.give(f1);  //이제훈이 강동원에게 과자를 주었다
		
		
	}

}
===================================================================
package collection;

public class Ex01 {
	public static void main(String[] args) {
		
		// collection : 수집하다, 모은다. 다수의 데이터를 저장
		// framework : 작업을 할 수 있도록 미리 준비된 틀
		
		// array : 다수의 데이터를 순번에 따라서 저장할 수 있는 자료구조
		
		// 다수의 데이터를 관리해야하고, 데이터의 형태가 복잡해질수록, 데이터를 저장하는 방식에 따라서
		// 프로그램의 효율이 달라질 수 있다.
		
		//순번 = 인덱스
		// List : 순번이 존재하고, 자료의 중복을 허용하는 자료구조
		// Set : 순번이 없고, 자료의 중복을 허용하지 않는 자료구조
		// Map : 순번대신 key라는 형식을 지정해서 사용할 수 있고, key는 중복될 수 없으나, value는 중복가능
		
		
		
	}

}

==========================================================================
package collection;

import java.util.ArrayList;
import java.util.List; // List는 인터페이스이지만, List를 상속받는 하위 여러클래스가 존재한다.
import java.util.Stack;
// 그중에 ArrayList이다.

public class Ex02 {

	public static void main(String[] args) {
		// 컬렉션은 기본적으로 여러 형태의 데이터를 묶어서 저장할 수 있다(저장하는 타입은 object이다)
		// List : 순번에 의해서 자료를 저장하고, 데이터의 중복을 허용하는 자료구조
		
		// java.util.List
		
		//List ob = new List(); //인터페이스라 객체생성xx
		
		ArrayList ob = new ArrayList();
		//이렇게 문자,숫자 다른 자료형도 저장가능 
		ob.add(10); //순서대로 인덱스가 할당
		ob.add(20);
		ob.add("ITBANK");
		ob.add(20);
		
		System.out.println(ob); //toString() 메서드가 오버라이딩되어있어서 바로 출력가능
		
		//중간에 데이터를 삽입하면 알아서 나머지값들이 뒤로밀린다.
		ob.add(1,30); //인덱스, 값 
		for(int i = 0; i<ob.size(); i++) { //arr.length -> list.size()
			System.out.printf("ob.get(%d) : %s\n", i, ob.get(i));
		} //arr[i] -> list.get(i)
		System.out.println();
		
		for(Object o : ob) { //ob(리스트)안에 있는 각요소를 o라고할때
			System.out.println(o); //o를 출력해라(순서대로)
		}
		
		Stack st = new Stack();
		st.push(10);
		st.push(10);
				
		System.out.println(st.pop());
		System.out.println(st.pop());
		
	}

}
==========================================================================
package collection;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// 컬렉션은 모든 객체 형태를 저장할 수 있도록 되어 있으나, 오히려 이것이 단점으로 작용하는 경우가 많다.
// Object에 정의되어 있지 않은 메서드는 호출 할 수 없다.

class Student {
	protected String name;
	protected int age;
	
	public Student(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	public void show() {
		System.out.println(name + "은 " + age + "살 입니다");
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}

public class Ex03 {

	public static void main(String[] args) {
		//이렇게 Object형식으로 만들면 upcasting이 되서 강제로 down-casting해야하는
		//번거로움이 발생해서  제네릭 타입을 쓴다 ArrayList<Student> 
		ArrayList list = new ArrayList(); 
		Student st1 = new Student("이지은", 29);
		Student st2 = new Student("홍진호", 40);
		Student st3 = new Student("김민준", 36); //객체 생성시에는 Student타입이었으나
		
		list.add(st1); //메서드에 전달하는 과정에서 Object 클래스로 up-casting되었다.
		//그래서 show()를 호출할수없다.(Object에 정의되있지 않아서)
		list.add(st2);
		list.add(st3);
		
		for(int i = 0; i<list.size(); i++) {
			//에러가 난다. 
			//list.get(i).show();
			
			//하지만 매번 이렇게 down-casting을 해줘야되나??
			Student st = (Student)list.get(i);
			st.show();
		}
		//에러가 난다. 너무많은 종류를 묶을려고 하다보니
//		for(Student st : list) { 
//			
//		}
		
		//내부 데이터 타입이 Student로 지정된 ArrayList 객체를 생성한다(다른자료형은 추가안됨)
		//java 1.5이상 제네릭타입가능
		ArrayList<Student> list2 = new ArrayList<Student>();
		
		Student[] arr = new Student[5];
		
		list2.add(st1);
		list2.add(st2);
		list2.add(st3);
		for(int i = 0; i<list2.size(); i++) {
			list2.get(i).setAge(list2.get(i).getAge()+1);
			list2.get(i).show();
		}
		Student[] arr1 = new Student[] {st1, st2, st3};
		//배열으 List형식으로 변환
		List<Student> list3 = Arrays.asList(arr1);
	
		//list.add(new Student("나단비",7)); //List에는 ㅁdd사용하기 힘들다.
		ArrayList<Student> list4 = new ArrayList<Student>(list3);
		list4.add(new Student("나단비",7));
		
		for(Student st : list4) {
			st.show();
		}
		
		list4.remove(2); // 2번쨰 요소를 제거하고 빈칸을 당긴다
		for(Student st : list4) {
			st.show();
		}
		
		//remove는 인덱스 또는 객체를 받을 수 있다.
		list4.remove(st1);
		for(Student st : list4) {
			st.show();
		}
	}

	
}
==========================================================================
package collection;

import java.util.HashSet;
import java.util.Set; //인터페이스 , Set을 구현한 하위클래스를 사용한다. -> hashset

public class Ex04 {

	public static void main(String[] args) {
	 // Set test = new Set(); 인터페이스다.
		
		//HashSet<int> set = new HashSet<int>();
		//제네릭 타입에는 primitive를 사용xx
		
		//순번x, 중복허용 x
		HashSet<Integer> set = new HashSet<Integer>();
		
		set.add(10);
		set.add(20);
		set.add(30);
		set.add(10);
		
		System.out.println(set.size()); //3개만 들어간다. 중복때문에
		
		for(int i = 0; i<set.size(); i++) {
			//set.get(i);   순번이 없어서 불가능
		}
		//integer와 int는 호환이되니까
		for(int num : set) {
			System.out.println(num);
		}
		
		//중복을 허용하지 않는 특징을 활용하자
		//1) 중복은 허용하지 않으면서, size()는 확인할 수 있으니, 중복되지 않는 일정 개수의 데이터를 만들 때 사용
		//2) 변수 및 객체의 이름은 코드상에서 중복되면 안되므로, 변수이름(Map의 key)을 저장할 때 사용한다
		
		
	}

}
==============================================================================















