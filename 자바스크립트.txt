//form에 날짜넣기(실시간)
<script>
		const today = new Date().toISOString().split('T')[0]  //new Date.tiISOString() -> 2021-12-10T04:42:08.128Z
		document.querySelector('input[type="date"]').value=today
</script>
=======================================================================
<%@ include file="header.jsp" %>
//alert-box 띄우기
<div id="alert" class="jcce aice ffc" 
		 style="border: 2px solid black;
		 		box-shadow: 5px 5px grey;
		 		width: 500px;
		 		height: 300px;
		 		margin: 50px auto;
		 		border-radius: 25px;
		 		
		 		opacity: 0;
		 		position: absolute;
		 		top: 50%;
		 		left: 25%;
		 		transition-duration: 0.5s">
		<div style="font-size: 16px; font-weight: bold; margin: 30px;">
			${msg }
		</div>
		<button class="btn">확인</button>
	</div>
	<script>
		const cpath='${cpath}'
		const msg = '${msg}'
		const url = '${url}' //로그인성공시 /login으로 , 실패시 공백으로 넘겨줬었다(MemberController)
		
		window.onload = function(event) { //문서가 로드되면 event가 실행
			const alert = document.getElementById('alert')
			alert.style.opacity = 1;
			alert.style.top = '30%';
		}
		document.querySelector('button').onclick = function() {
			if(url == '') { //주소가없으면 이전페이지로 
	 			history.go(-1); //입력했던 값이 남아있다.
	 		}
	 		else{
	 			location.href= cpath + '/' +url	
	 		}
		}
===================================================================================
//login확인
<script>
		const flag = '${not empty login}'
		let url = '${cpath}'	// 로그인 성공시 이동할 주소는 기본적으로 대문페이지 이지만 
		
		if(flag == 'true') {							// 로그인에 성공했으면서
			if('${not empty param.url}' == 'true') {	// 파라미터 url이 존재한다면
				url = '${param.url}'					// url 변수에 파라미터 값을 넣어주고
			}	
			location.href = url		// 기본값 혹은 전달받은 파라미터 주소로 페이지를 이동한다
									// 세션에 저장된 내용은 페이지 이동에 상관없이 참조할 수 있다
		}								
		else {
			alert('로그인 실패 !!')
			history.go(-1)
		}
	</script> 
=========================================================================================
// for, while, forEach 방식 
console.log('## for ##');
const colors = ['red', 'blue', 'green'];
for (let i = 0; i < colors.length; i++) {
	console.log( colors[i] );
}

console.log('## while ##');	
var i=0;
while (colors[i] != null) {
  console.log( colors[i] );
  i++;
}

console.log('## forEach ##');
colors.forEach(function(value) {
  console.log(value);
});

console.log('## forEach with Arrow ##');
colors.forEach( value => console.log(value));


const colors = ['red', 'blue', 'green'];

console.log('## for-in ##');
for (var index in colors) {
	console.log( colors[index] );
}

console.log('## for-of-for ##');
for (var value of colors) {
	console.log( value );
}
============================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table {
            border-collapse: collapse;
        }
        th,td {
            border: 2px solid black;
            padding: 10px;
            font-size: 20px;
        }
        th {
            background-color: #dadada;
        }
        .root {
            display: flex;
        }
    </style>
</head>
<body>
    <script src="ex01.js"></script>
    <h1>필터링과 정렬</h1>
    <hr>
    <div class="root">
        <div class="left">
            <fieldset>
                <p><label><input type="radio" name="agefilter" value="10">10대</label></p>
                <p><label><input type="radio" name="agefilter" value="20">20대</label></p>
                <p><label><input type="radio" name="agefilter" value="30">30대</label></p>
                <p><label><input type="radio" name="agefilter" value="40">40대</label></p>
            </fieldset>
            <fieldset>
                <p><label><input type="radio" name="genderfilter" value="남성">남성</label></p>
                <p><label><input type="radio" name="genderfilter" value="여성">여성</label></p>
            </fieldset>
        </div>
        <div class="right">
            <table>
                <thead>
                    <tr>
                        <th>이름</th>
                        <th>나이</th>
                        <th>성별</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <script>
        //List<DTO> list =Arrays.asList(new DTO[] {dto1,dto2,dto3});
        //list.forEach(dto) -> {
        //    System.out.println(dto.getName());
        //}

        const arr = [
            {name: '이지은', age: 29, gender: '여성'},
            {name: '홍진호', age: 40, gender: '남성'},
            {name: '나단비', age: 7, gender: '여성'},
            {name: '해적왕', age: 18, gender: '남성'},
            {name: '이병건', age: 39, gender: '남성'},
        ]

        const tbody = document.querySelector('.right tbody')
        tbody.innerHTML = ''
        arr.forEach(dto => {
            const tr = convert(dto)  //함수작성은 맨위에
            tbody.appendChild(tr)
        })

        const boxList = document.querySelectorAll('.left input[type="radio"]')
        console.log(boxList)
        boxList.forEach(box=>box.onclick = filterHandler)
    </script>
</body>
</html>
-------------

//함수작성은 여기서
function convert(dto) {
    const tr = document.createElement('tr')
    for(key in dto)  { //객체의 속성만큼 반복
        const td1 = document.createElement('td')
        const value = dto[key]
        td1.innerText = value
        tr.appendChild(td1)
    }
    return tr
}

//중복필터
function filterHandler(event) {
    //console.log(event.target.name) // radio버튼을 클릭함에 따라 agefilter, namefilter 가 나온다 
    
    //클릭할때마다 선택되어 있는 필터항목만 가져온다(input에서 체크되있는것만 가져와라)
    const checkedFilter = document.querySelectorAll('.left input:checked')
    checkedFilter.forEach(element => console.log(element.dataset))
    console.log(checkedFilter)//nodeList[input]

    const ob = {}  //빈 객체선언
    checkedFilter.forEach(e => ob[e.name] = e.value) //비어있는 객체에 값 넣기 -> 체크되있는 거만 ob[e.name]하면 생긴다 , 
    console.log(ob) //10대를(age)클릭하면 filterage: 10 만나온다
    //arr.filter는 원본은 변경하지않고, 변경된 배열을 반환한다 <--> sort는 원본변경
    const filterArr = arr.filter(dto => { 
        let flag = true
        const flag1 = +ob.agefilter <= dto.age && dto.age < +ob.agefilter +10
        const flag2 = ob.genderfilter == dto.gender
        if(ob.agefilter != undefined) { //체크를 하면
            flag = flag && flag1
            console.log('agefilter: ' + flag)
        }
        
        if(ob.genderfilter != undefined) { 
            flag = flag && flag2
            console.log('genderfilter: ' + flag)
        }
        console.log('result: '+flag)
        return flag
    })
    tbody.innerHTML = ''
    filterArr.forEach(dto => {
        const tr = convert(dto)
        tbody.appendChild(tr)
    })
}

================================================================================================================
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link type="text/css" rel="stylesheet" href="quiz01.css">
</head>
<body>
    <script src="quiz01.js"></script>
    <h1>중복 선택 가능한 필터와 정렬</h1>
    <hr>
    <h3>음식을 주제로 사진, 이름, 가격, (카테고리)로 데이터를 구성하고 기능적용하세요</h3>

    <div class="root">
        <div class="left">
            <div class="filter category">
                <label><input type="checkbox" name="category" value="한식">한식</label>
                <label><input type="checkbox" name="category" value="일식">일식</label>
                <label><input type="checkbox" name="category" value="중식">중식</label>
                <label><input type="checkbox" name="category" value="양식">양식</label>
                <label><input type="checkbox" name="category" value="분식">분식</label>
            </div>
            <div class="filter price">
                <label><input type="checkbox" name="price" value="0">1만원 미만</label>
                <label><input type="checkbox" name="price" value="10000">1만원 대</label>
                <label><input type="checkbox" name="price" value="20000">2만원 대</label>
                <label><input type="checkbox" name="price" value="30000">3만원 대</label>
                <label><input type="checkbox" name="price" value="40000">4만원 이상</label>

            </div>
            <div class="sort">
                <label><input type="radio" name="sort" value="name">이름순</label>
                <label><input type="radio" name="sort" value="price">가격순</label>
            </div>
        </div>
        <div class="right"></div>
    </div>

    <script>
        const arr = getDataArray()
        const right = document.querySelector('.right')
        const dom = getDom(arr)
        render(right, dom)

        const categoryFilterList = document.querySelectorAll('.left input')
        categoryFilterList.forEach(element => element.addEventListener('click', filterHandler))
    </script>


</body>
</html>
-----------------
function getDataArray() {
    const arr = [
        {category: '한식', name: '소고기전골', price: '30000', img: 'https://sjnfzdfjrjgl1655541.cdn.ntruss.com/goods/3/2020/11/522_tmp_486b82934924f4ccb46ed67c4095e8fb6417view.jpg'},
        {category: '중식', name: '나가사키짬뽕', price: '8500', img: 'https://w.namu.la/s/da28524841fa2a5b638f9a3977c8461bd5b5b5c02d3aa1bb24bbacb7aea04e535aca56168be0508f1e2f8dca08fa5a3b50119aed97e42c5ae6b0646f152551ce8410a25718d30b8809524ae4a7eca31d'},
        {category: '일식', name: '초밥', price: '17000', img: 'https://rimage.gnst.jp/livejapan.com/public/article/detail/a/00/00/a0000370/img/basic/a0000370_main.jpg?20201002142956&q=80&rw=750&rh=536'},
        {category: '양식', name: '로제크림파스타', price: '23500', img: 'https://recipe1.ezmember.co.kr/cache/recipe/2019/03/03/fca1b1c8f05592f409b6fbe702e2112a1.jpg'},
        {category: '한식', name: '돼지국밥', price: '7500', img: 'https://folkency.nfm.go.kr/upload/img/20190304/20190304095002_t_.jpg'},
        {category: '일식', name: '치즈돈까스', price: '9000', img: 'https://mblogthumb-phinf.pstatic.net/MjAxOTAzMDlfMTUz/MDAxNTUyMTM0Nzk4NjQ5.m-E374BrP6gDkKCQAOoDPPBPipt8AVeOmm51uwsVx1gg.2C3J3SeDRXXsHV-OrGZG5G_tLhHmR6Bqd1Aagf7_3v4g.JPEG.fredda/20190302004143.JPG?type=w800'},
        {category: '분식', name: '참치김밥', price: '4500', img: 'https://recipe1.ezmember.co.kr/cache/recipe/2020/09/22/166346648fac6569fe71776696cabd1d1.jpg'},
        {category: '중식', name: '오향장육', price: '29000', img: 'https://ww.namu.la/s/c8ef74e18b1f324d707c7bf564a4c83a7d2193c7a9897af72cdea5552a0fc732000e07be1b8cb2bce1125b628d09e96a2e8ca7a65ec7eae060758c74284b15f7b6e5618240f881a82a07e8d6dfeb36c7857592314aeadf8422f1a39fb5b5d2e4'},
        {category: '일식', name: '타코와사비', price: '12000', img: 'https://img-cf.kurly.com/shop/data/goodsview/20180913/gv10000032046_1.jpg'},
        {category: '분식', name: '떡볶이', price: '10000', img: 'https://cdn.meesig.com/v3/prod/image/item/mainpage/907/ad4474bef39c4167b84477eaa7a5052f20210708171733.'},
        {category: '양식', name: '스테이크', price: '49000', img: 'https://ww.namu.la/s/3c37e944ae486477fea075e4bff27a9c696e0ad1016535bbaac3bbd31a8ec55a0f7be21bd6fa7f41b1bc00832e4fba6d2ec14e36bd99ed7f9418c25844393869f317186b7ccd335c66411a0df5ed29ac0b7f89194a61156fc75bf6467e62762b'},
    ]
    return arr
}

function getDom(arr) {
    let dom = ''
    arr.forEach(dto => {
        dom += `<div class="item">`
        dom += `<div><img src="${dto.img}"></div>`
        dom += `<div><strong>${dto.name}</strong></div>`
        dom += `<div>가격 : ${dto.price}</div>`
        dom += `<div>분류 : ${dto.category}</div>`
        dom += `</div>`
    })
    return dom
}

function render(target, dom) {
    target.innerHTML = ''
    if(typeof dom == 'string')      target.innerHTML = dom
    else                            target.appendChild(dom)
}

function filterHandler(event) {
    const categoryFilterArray = Array.from(document.querySelectorAll('.left input[name="category"]:checked')).map(v => v.value)
    const priceFilterArray = Array.from(document.querySelectorAll('.left input[name="price"]:checked')).map(v => +v.value)//input은 type,value 등 도 있는데 value로만 배열을 재구성(map은 재배열함수이다, 자바의 hashmap이 아니다)
    const sort = document.querySelector('.left input[name="sort"]:checked')

    console.log(categoryFilterArray)
    console.log(priceFilterArray)
    console.log(sort)
    console.log('')

    const result = arr.filter(dto => {
        // 카테고리
        const flag1 = categoryFilterArray.includes(dto.category)

        // console.log(Math.floor(dto.price / 10000) * 10000)
        const flag2 = priceFilterArray.includes(Math.floor(dto.price / 10000) * 10000)

        let flag = true
        if(categoryFilterArray != 0) {  
            flag = flag && flag1
            console.log(flag)
        }
        if(priceFilterArray != 0)  {
            flag = flag && flag2
            console.log(flag)
        } 
        return flag
    })
    if(sort != null) {  //사용자입장에서 가격순, 이름순으로 정렬체크를 안할수도 있고 할수도 있다. 
        switch(sort.value) {
            case 'price':
                result.sort((a, b) => +a[sort.value] > +b[sort.value] ? 1 : -1) //price.value에 접근-> 정수형으로 바꿨다(+)
                break
            case 'name':
                result.sort((a, b) => a[sort.value] > b[sort.value] ? 1 : -1)
                break
        }
    }

    render(right, getDom(result))
}
=============================================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table {
            border-collapse: collapse;
        }
        th,td {
            border: 2px solid black;
            padding: 10px;
            font-size: 20px;
        }
        th {
            background-color: #dadada;
        }
        .root {
            display: flex;
        }
    </style>
</head>
<body>
    <script src="ex03.js"></script> <!--ex03.js에 필요한 모든 함수를 정의할 예정-->
    <h1>필터링과 정렬</h1>
    <hr>
    <div class="root">
        <div class="left">
            <fieldset>
                <p><label><input type="checkbox" name="agefilter" value="10">10대</label></p>
                <p><label><input type="checkbox" name="agefilter" value="20">20대</label></p>
                <p><label><input type="checkbox" name="agefilter" value="30">30대</label></p>
                <p><label><input type="checkbox" name="agefilter" value="40">40대</label></p>
            </fieldset>
        </div>
        <div class="right">
            <table>
                <thead>
                    <tr>
                        <th>이름</th>
                        <th>나이</th>
                        <th>성별</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <script>
        //여기에는 문서에서 요소를 불러오거나
        //함수로 객체를 불러와서
        //여러 함수를 호출하여 데이터를 처리하고 화면에 반영하는 작업
        //이벤트함수연결
        const data = getData()  //데이터를 불러오고(ex03.js)
        const tbody = document.querySelector('.right tbody')  //HTML요소불러와서
        const dom = getDom(data) //데이터를 dom으로 변환하고
        render(tbody,dom) //dom을 html요소에 그린다(첫화면)

        const boxList = document.querySelectorAll('.left input[type="checkbox"]');
        boxList.forEach(box => box.onclick = filterHandler)  //클릭하면 함수실행
    </script>
</body>
</html>
--------------------
function getData() {
    const arr = [
        {name: '이지은', age: 29, gender: '여성'},
        {name: '홍진호', age: 40, gender: '남성'},
        {name: '나단비', age: 7, gender: '여성'},
        {name: '해적왕', age: 18, gender: '남성'},
        {name: '이병건', age: 39, gender: '남성'},
    ]
    return arr
}

function getDom(data) { //데이터를 받아서 문자열 태그형식으로 반환
    let dom = ''
    data.sort((a,b) => a.age > b.age ? 1 : -1)
    data.forEach(dto =>  {
        dom += `<tr><td>${dto.name}</td><td>${dto.age}</td><td>${dto.gender}</td></tr>`
    })
    return dom
}

function render(target, dom) { //대상과 돔을 받아서 대상에 dom을 그리기
    console.log(typeof dom) //string
    target.innerHTML = ''
    if(typeof dom =='string') target.innerHTML += dom;
    else                      target.appendChild(dom)
    
}
 
function filterHandler(event) {
    const checkedFilterList = document.querySelectorAll('input:checked')
    console.log(checkedFilterList)
    const checkedFilterArray = Array.from(checkedFilterList).map(v=>+v.value) //list를 배열로만들어서 map함수를 호출(inputtag: v , +v.value = checked된값(정수로바꿔서))
    if(checkedFilterArray == 0){
        render(tbody, getDom(data))
        return
    }
    // console.log(data)
    // console.log(tbody)
    //console.log(checkedFilter)
    const filterArr = data.filter(dto => {
        //10의 자리수만 (10,20,30 이렇게 나옴)
        const age = Math.floor(dto.age/10) * 10
        return checkedFilterArray.includes(age)  //dto.age가 checkedFilterArray에 포함되있으면
    })

    //filterArr.sort((a,b) => a.age > b.age ? 1 : -1) //정렬하고 아래 render
    //위에서 정렬한 배열을(filterArr) 여기에 매개변수로 넣기
    render(tbody, getDom(filterArr))  //내가빼낸 배열을 tbody안에 그려라
}
====================================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table {
            border-collapse: collapse;
        }
        th,td {
            border: 2px solid black;
            padding: 10px;
            font-size: 20px;
        }
        th {
            background-color: #dadada;
        }
        .root {
            display: flex;
        }
    </style>
</head>
<body>
    <script src="ex01 copy.js"></script>
    <h1>필터링과 정렬</h1>
    <hr>
    <div class="root">
        <div class="left">
            <fieldset>
                <p><label><input type="radio" name="agefilter" data-age="10">10대</label></p>
                <p><label><input type="radio" name="agefilter" data-age="20">20대</label></p>
                <p><label><input type="radio" name="agefilter" data-age="30">30대</label></p>
                <p><label><input type="radio" name="agefilter" data-age="40">40대</label></p>
            </fieldset>
            <fieldset>
                <p><label><input type="radio" name="genderfilter" value="남성">남성</label></p>
                <p><label><input type="radio" name="genderfilter" value="여성">여성</label></p>
            </fieldset>
        </div>
        <div class="right">
            <table>
                <thead>
                    <tr>
                        <th>이름</th>
                        <th>나이</th>
                        <th>성별</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <script>
        //List<DTO> list =Arrays.asList(new DTO[] {dto1,dto2,dto3});
        //list.forEach(dto) -> {
        //    System.out.println(dto.getName());
        //}

        const arr = [
            {name: '이지은', age: 29, gender: '여성'},
            {name: '홍진호', age: 40, gender: '남성'},
            {name: '나단비', age: 7, gender: '여성'},
            {name: '해적왕', age: 18, gender: '남성'},
            {name: '이병건', age: 39, gender: '남성'},
        ]

        const tbody = document.querySelector('.right tbody')
        tbody.innerHTML = ''
        arr.forEach(dto => {
            const tr = convert(dto)  //함수작성은 맨위에
            tbody.appendChild(tr)
        })

        const boxList = document.querySelectorAll('.left input[type="radio"]')
        console.log(boxList)
        boxList.forEach(box=>box.onclick = filterHandler)
    </script>
</body>
</html>
----------------

//함수작성은 여기서
function convert(dto) {
    const tr = document.createElement('tr')
    for(key in dto)  { //객체의 속성만큼 반복
        const td1 = document.createElement('td')
        const value = dto[key]
        td1.innerText = value
        tr.appendChild(td1)
    }
    return tr
}

function filterHandler(event) {
    console.log(event.target)
    const age = +event.target.dataset.age //숫자로불러와라 (+)
    console.log(age)
    console.log(arr) //html파일에서 실행되기때문에(선언된곳이 html내부라서) 그래서 arr도 부를수있다 
    
    //arr.filter는 원본은 변경하지않고, 변경된 배열을 반환한다 <--> sort는 원본변경
    const filterArr = arr.filter(dto=> age <= dto.age && dto.age < age+10)
    tbody.innerHTML = ''
    filterArr.forEach(dto => {
        const tr = convert(dto)
        tbody.appendChild(tr)
    })
}

=================================================================================================
function getDom(json) {
console.log('getDom호출!!')

let tag = '<div>';
json.forEach(dto => {
tag += '<div><img src="' +dto.filesource + '"style="box-shadow: 0 4px 4px -4px gray;"></div>'
tag += '<div>'+ dto.menuname +'</div>'
tag += '<div style="font-size: 0.8rem; color: #44900c;">가격 ￦ '+ dto.price + '</div>'
tag += '<div style="font-size: 0.8rem;">'+ dto.kcal +'Kcal</div>'
})
tag += '</div>'
return tag;
}
============================================================================================
#)해시맵으로 받으면(json(DTO)를) key값이 대문자로 넘어온다. 그래서 render할 때 dom에서 dto.IMG이렇게 받아야한다.

map.put("title","자동차정비")
for(String key : map.keySet()) {
	System.out.println(key + ", " + map.get(key));
}

위와 같은 개념이다.

const formData = new FormData(event.target)
	for(key of formData.keys()) {
		console.log(key,formData.get(key))
}
============================================================================
<h1>이미지 갤러리</h1>
<form method="POST" enctype="multipart/form-data" action="${cpath }/upload2">
	<p><input type="file" name="uploadFile" required></p>
	<p><input type="hidden" name="username" value="${login.username }"></p>
	<p><input type="submit" value="전송"></p>  <!-- form 안에 button을 넣으면  -->
</form>

<div style="display: flex; width: 800px; flex-flow: wrap; border: 2px solid black; padding: 20px;" >
		<c:forEach var="dto" items="${list }">
			<div style="border: 1px solid blue; padding: 10px; margin-right: 10px; box-sizing: border-box; width: 45%; height: 250px; margin-bottom: 5px;">
					<img src="${cpath}/upload/${dto.modname }">
					<div>작성자:  ${dto.username }</div>
					<button class="deleteBtn" data-del="${dto.idx }">삭제</button>
					<button class="modifyBtn" data-mod="${dto.idx }">수정</button>
			</div>
		</c:forEach>
</div>

	<script>
		const cpath = '${cpath}'
	
		const deleteList = document.querySelectorAll('.deleteBtn')
		console.log(deleteList)
		deleteList.forEach(btn => {
			btn.onclick=function(event) {
				const idx = event.target.dataset.del
				location.href = cpath + '/delete/' + idx 
			}
		})
		
		const modifyList = document.querySelectorAll('.modifyBtn')
		modifyList.forEach(btn => {
			btn.onclick=function(event) {
				const idx = event.target.dataset.mod
				location.href = cpath + '/modify/' + idx 
			}
		})
	</script>
============================================================================
Hash 처리 -> DB에 password컬럼을 varchar(500)을 잡는 이유는 hash처리때문이다.
- 데이터를 보안하는 방법에는 크게 2가지로 나눈다
1)Hash : 단방향 -> 원래있던데이터를 뭉갠다.(원본복구불가능, 데이터를 아주 잘게 자른다(데이터성질자체는 안바뀐다)일치여부 판단가능)
2)Encryption: 양방향 변환, 키가 있으면 원본데이터로 돌려놓는것이 가능(SSL, SSH, HTTPS -> 암호화해서 나중에 다시 알아볼수있게가능)

요청 -> 디스패처는 매핑된 컨트롤러를 찾는다.(homecontroller를 지운다면)
servlet.context에서 설정
<view-controller path="/" view-name="home"/> 이렇게하면 홈컨트롤러가없음에도 jsp가 뜬다
<!-- 
		컨트롤러의 특정 수행내용없이 단순히 view를 띄우기 위해서라면
		dispatcherServlet이 곧바로 viewName을 지정해서 jsp로 포워딩하게 설정한다.
		
		주의점) 메서드 구분할 수 없음(GET/POST) 즉, 어떤메서드던지 jsp로 간다면
		모든 방식의 메서드에 대해서 작동한다.
-->
===============================================================================
ajax로 요청시 주소창이 바뀌면안된다 (파라미터가 주소창에 찍히거나 등등)

iterable 인터페이스에 iterator()란 메서드가 있고 -> hasNext(), next() 메서드가 있다.

//for-each에서는 삭제불가능
for (String i : list) {
    System.out.println(i);
    list.remove(i); // throws exception
} 

Iterator it=list.iterator();
while (it.hasNext()){
    System.out.println(it.next());
    it.remove(); // valid here
}
==================================================================================
#)JSON 과 자바스크립트객체
#)JSON.stringify
JSON.stringify() 메소드는 인수로 전달받은 자바스크립트 객체(JSON형식)를 문자열로 변환하여 반환합니다.


var dog = {name: "식빵", family: "웰시코기", age: 1, weight: 2.14}; // 자바스크립트 객체
var data = JSON.stringify(dog);                    // 자바스크립트 객체를 문자열로 변환함.

document.getElementById("json").innerHTML = data;
-->{"name":"식빵","family":"웰시코기","age":1,"weight":2.14}  //문자열로 변환하면 key가  ""처리가된다

-------------
#)JSON.parse
JSON.parse() 메소드는 JSON.stringify() 메소드와는 반대로 인수로 전달받은 문자열(json문자열)을 자바스크립트 객체로 변환하여 반환합니다.
var data = '{"name": "식빵", "family": "웰시코기", "age": 1, "weight": 2.14}'; // JSON 형식의 문자열
var dog = JSON.parse(data);                       // JSON 형식의 문자열을 자바스크립트 객체로 변환함.
document.getElementById("json").innerHTML = dog + "<br>";
document.getElementById("json").innerHTML += dog.name + ", " + dog.family;
//결과(자바스크립트 객체로 변환했기때문에->parse .(점)으로 접근가능
[object Object]
식빵, 웰시코기

------------
#)date
<p id="json"></p>

	<script>
		var date = new Date();		// 자바스크립트 Date 객체
		var str = date.toJSON();	// Date 객체를 JSON 형식의 문자열로 변환함.

		document.getElementById("json").innerHTML = date + "<br>";
		document.getElementById("json").innerHTML += str;
	</script>
//결과
Sun Jan 02 2022 22:26:00 GMT+0900 (한국 표준시) // 자바스크립트 Date 객체
2022-01-02T13:26:00.536Z // Date 객체를 JSON 형식의 문자열로 변환함.
==========================================================================
public String burger()
return "/menu/burger" --> /WEB-INF/views/menu/burger.jsp로

같다.

@GetMapping("/burger")
public void burger() {}
=================================================================================
#)잘못된 객체병합
var car = {
    weight: 3.5,
    color: 'red',
    speed: 50
}
 
var truckSpecific = {
    availableWeight: 25,
    registerYn: true
}
 
var superCarSpecific = {
    zeroToHundred: 3.4,
    convertable: false
}
 
var truck = Object.assign(car, truckSpecific);
var superCar = Object.assign(car, superCarSpecific);
 
console.log(truck);  
// {weight: 3.5, color: 'red', speed: 50, availableWeight: 25, registerYn: true}
console.log(superCar); 
// {weight: 3.5, color: 'red', speed: 50, availableWeight: 25, registerYn: true, zeroToHundred: 3.4, convertable: false }

========================================================================================
#)객체 병합
var car = {
    weight: 3.5,
    color: 'red',
    speed: 50
}
 
var truckSpecific = {
    availableWeight: 25,
    registerYn: true
}
 
var superCarSpecific = {
    zeroToHundred: 3.4,
    convertable: false
}
 
var truckTarget = JSON.parse(JSON.stringify(car));
var superCarTarget = JSON.parse(JSON.stringify(car));
 
var truck = Object.assign(truckTarget, truckSpecific);
var superCar = Object.assign(superCarTarget, superCarSpecific);
 
console.log(truck);  
// {weight: 3.5, color: 'red', speed: 50, availableWeight: 25, registerYn: true}
console.log(superCar); 
// {weight: 3.5, color: 'red', speed: 50, zeroToHundred: 3.4, convertable: false }
=======================================================================================
#)db에있는값으로 검색자동완성
<input type="search" name="search" list="search-list" autocomplete="off">
<datalist id="search-list">
	<option>부산 광안리</option>  //option안의 값은 db에서 불러온다
	<option>부산 광안리</option>
	<option>부산 광안리</option>
	..
</datalist>
============================================================================================
#)form태그안에 div
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>home.jsp</title>
<style>
	h3 {
		margin: 5px;
	}
	.box {
		width: 500px;
		box-sizing: border-box;
		display: flex;
		flex-flow: column;
		justify-content: center;
		border: 2px solid black;
		border-radius: 10px;
		margin-top: 10px;
		padding: 10px;
	}
	.hidden {
		display: none;
	}
</style>
</head>
<body>
	<h1>day15 - hash, mail</h1>
	<hr>
	
	<form id="sendMailForm">
		<div class="box">
			<h3>이메일 주소 입력</h3>
			<div>
				<input type="email" name="email" placeholder="이메일 주소" required autofocus autocomplete="off">
				<input type="submit" value="인증번호 전송">
			</div>
			<div id="sendMailMsg"></div>
		</div>
	</form>
	
	<form id="authMailForm" class="hidden">
		<div class="box">
			<h3>인증번호 입력</h3>
			<div class="timer"></div>
			<div>
				<input type="text" name="auth" placeholder="인증번호를 입력하세요">
				<input type="submit" value="전송">
			</div>
			<div id="authMailMsg"></div>
		</div>
	</form>
	
	<script>
	 //이메일전송누르면 썻던 이메일을 나두기위해서 ajax를 쓴다
	 const sendMailForm = document.getElementById('sendMailForm')
	 const sendMailMsg = document.getElementById('sendMailMsg')
	 const authMailForm = document.getElementById('authMailForm')
	 const authMailMsg = document.getElementById('authMailMsg')
	 const cpath = '${pageContext.request.contextPath}'
	 let second = 5
	 let interval = 0
	       function timer() {
	            console.log('interval')
	    
	            let min = Math.floor(second/60) + '' //정수처리를위해
	            let sec = second % 60 +''
	            if(min.length < 2) min = '0' + min
	            if(sec.length < 2) sec = '0' + sec
	            const format = min + ' : '  + sec  //자바스크립트는 ${min} el태그 안된다
	            const div = document.querySelector('.timer')
	            div.innerText = format
	            if(second <= 0) {
	            	div.style.color = 'red'
	                clearInterval(interval)
	                authMailForm.querySelector('input').placeholder='유효시간이 지났습니다'
	                authMailForm.querySelector('input').disabled='disabled'
	            	
	                authMailMsg.innerText = '인증번호를 다시발송해주세요'
	                authMailMsg.style.color='red'
	            }
	            second -= 1
	        }
	 function sendMailHandler(event) {
		 event.preventDefault()
		 const email = event.target.querySelector('input[name="email"]')
		 const url = cpath + '/mailto/' + email.value + '/'  //pathVariable를 쓸때 특수문자를 위해서 /로 끝나게해야한다. //요청과 응답의 주소가 다르면 -> 크로스오리진
		 //const url ='http://192~/day15~' //이렇게하면안된다. 그래서 controller에서 @CrossOrigin을 써주면 들어오는 요청을 허용하겠다라는것이된다. 이렇게 열어줘야 url='http~' 가능하다
		 
		 const opt = {
			 method: 'GET'
		 }
		 fetch(url, opt)
		 .then(resp => resp.json())
		 .then(json => {
			console.log(json)
			sendMailMsg.innerText=json.message
			sendMailMsg.style.color = json.status == 'OK' ? 'blue' : 'red'
			if(json.status == 'OK') {
				authMailForm.classList.remove('hidden')
				
				interval = setInterval(timer,1000)  //멈추고싶으면 clearInterval(interval)
				second = 180 //메일을 보내고 나면 시간을 초기화한다
				authMailForm.querySelector('input').disabled=''
				authMailForm.querySelector('input').placeholder='인증번호를 입력하세요'
				authMailForm.querySelector('input').focus()
				authMailMsg.innerText=''
			}
		 })
	 }
	 //인증번호를 입력하면 작동하는 함수
	 function authMailHandler(event) {
		 event.preventDefault()
		 if(second <= 0) {
			 alert('유효시간이 지났습니다. 다시 메일을 보내주세요')
			 return //유효시간이 만료되었다면 이후 코드를 진행하지 않는다
		 }
		 //form에 name="auth"를 불러오자
		 const auth = event.target.querySelector('input[name="auth"]')
		 const url = cpath + '/getAuthResult/' + auth.value + '/'
		 const opt = {
			 method: 'GET'
		 }
		 fetch(url, opt)
		 .then(resp => resp.json())
		 .then(json => {
			//console.log(json)
			authMailMsg.innerText = json.message
			if(json.status == 'OK') {
				authMailMsg.style.color = 'blue'
				auth.disabled = 'disabled' //인증이 완료되면 더이상 인증번호를 바꿀수없게끔 한다.(입력창을 수정못한다는 소리)
				//인증에 통과했을 경우 진행할 수 있는 다음 버튼을 보여주거나 하면된다.
				clearInterval(interval)  //인증이 다되면 타이머가 진행되지않도록 막자
				document.querySelecotr('.timer').innerHTML='' //시간도 지우고
			}
			else {
				authMailMsg.style.color = 'red'
				auth.select() //틀리면 인증번호가 드래그된다.
			}
		 })
		 
	 }
	 //페이지이동하면안된다. -> preventdefault
	 sendMailForm.onsubmit = sendMailHandler
	 authMailForm.onsubmit = authMailHandler
	</script>
</body>
</html>
==============================================================================================
#)hashmap
String result = mailService.sendMail(email, authNumber, account);  //account에는 이메일계정/비밀번호 들어가있다
		
		HashMap<String,String> ret = new HashMap<String, String>();
		if(result.equals(authNumber)) {
			ret.put("status", "OK");
			ret.put("message", "인증번호가 발송되었습니다");
		}
		else {
			ret.put("status", "FAIL");
			ret.put("message","인증번호 발송에 실패했습니다");
		}
		
		return ret;
===========================================================================
#)jsp
<form>
	<input type="checkbox:" name="name" values="ㅇㅇㅇ">
	<input type="checkbox:" name="name" values="ㄴㄴㄴ">
	<input type="checkbox:" name="name" values="ㅁㅁㅁ">
</form>

<%
String[] name = request.getParameterValues("name");
if(name != null) {
	out.print("선택한 멤버는 ");
	for(int i = 0; i<name.lengthl i++) {
		String value = name[i];
		out.println(value);
		out.print(i != name.length - 1 ? ", " : "입니다");
	}
}
%>
===============================================================================
웹사이트를 준비하기 위해서 일반적으로 구성하는 3가지 서버
- Web Server  (WAS, Tomcat)  -> 처리만
- DB Server   (oracle) -> 내부데이터 보관 및 쿼리
- Static Resource Server  (AWS S3 Bucket)  -> 파일지원 보관(각종 압축파일, 이미지 파일 등)

-----------------------------------------
SSH안에 딸려있는 기능 ssh,scp, sftp

1)거의 대부분의 리눅스가 기본적으로 설치되어있다
2) Secure Shell 이 적용되있다. -> 데이터가 암호화되서 전송된다(SSL)

1)maven에서 
jsch -> pom.xml
2)web.xml
3)<view-controller path="/" view-name="home" /> -> servlet.context
4)root-context에서는 (day13복사)
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
	
	<!-- Root Context: defines shared resources visible to all other web components -->
		<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
		<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
		<property name="jdbcUrl" value="jdbc:oracle:thin:@221.164.9.200:50000:xe"/>
		<property name="username" value="c##itbank"/>
		<property name="password" value="it"/>
	</bean>
	
	<!-- 기존은 c3p를 썼었다 -->
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
		<constructor-arg ref="hikariConfig"/>
	</bean>	
	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />

		
	</bean>
	
	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate" destroy-method="close">
		<constructor-arg ref="sqlSessionFactory" />
	</bean>
	
	<context:component-scan base-package="com.itbank.service"/>
	
	<!-- mybatis-spring은 인터페이스를 스캔 -->
	<mybatis-spring:scan base-package="com.itbank.model"/>
</beans>


5)home.jsp
<%@ taglib~>
<c:set ~~ cpath>

<h1>정적 파일 서버 연동하기(sftp)</h1>
<hr>

<form method="POST" action="${cpath}/upload" enctype="multipart/form-data">
	<input type="file" name="uploadFile">
	<input type="submit">
</form>

<c:if test="${not empty uploadFilePath}">   //업로드한 이미지를 바로 찍을 때 -> 우클릭해서 복사하면 db에 있는 주소가 나온다.
	<img src="${uploadFilePath}">
</c:if>
6)UploadController

@Controller
public class UploadController {
	@Autowired private UploadService us;
	@PostMapping("/upload")
	public String upload(SftpDTO dto) throws Exception{
		System.out.println(dto.getUploadFile().getOriginalFilename());
		String uploadFilePath = us.upload(dto);
		
		return "redirect:/";
	}
}

7)sqldeveloper에서
create table sftp (
	uploadFilePath varchar2(500)   //http~
);

8)SftpDTO (model패키지에)
public class SftpDTO {
	private Multipart uploadFile;
	private String uploadFilePath;
	
	getter,setter생성
}

9) @Service
public class UploadService {
	//파일전송에 필요한 정보
	private final String serverIP = "내 리눅스ip";
	private final int serverPort = 22;
	private final String serverUser="root";
	private final String serverPass="root";
	private ChannelSftp chSftp = null;
	
	@Autowired private UploadDAO dao;
	
	public String upload(SftpDTO dto) {
		//1) 업로드 받은 파일을 임시파일로 웹서버에 생성
		MultipartFile file = dto.getUploadFile();
		File dest = new File(file.getOriginalFilename());
		file.transferTo(dest);
		//2) 웹서버에 생성된 임시파일을 파일서버에 전송
		Seesion sess = null;
		Channel channel = null;
		JSch jsch = new JSch();
		
		sess=jsch.getSession(serverUser, serverIp, serverPort);
		sess.setPassword(serverPass);
		sess=setConfig("StrictHostKeyChecking", "no");  //처음접속할때 키 체크 안한다
		sess.connect();
		
		channel = sess.openChannel("sftp");
		channel.connect();
		
		chSftp = (ChannelSftp) channel; //리눅스서버에 sftp형식으로 접속이 가능하다
		
		FileInputStream fis = new FileInputStream(dest);   //만들어진 파일을 입력받을 수 있게 stream으로 열어놓기
		chSftp.cd("/var/www/html");   //디렉토리 이동
		chSftp.put(fis, dest.getName()); //fis파일을 읽어내서 똑같은 이름으로 전송
		System.out.println("sftp> transfer complete");
		
		fis.close();
		chSftp.exit();
		
		String uploadFilePath ="";
		uploadFilePath +="http://";
		uploadFilePath +=serverIP;
		uploadFilePath +=":1234";  //기본포트는 80이며 작성필요없으나, 서비스가 중복된다면 별도로 지정해야한다
		uploadFilePath +="/" + dest.getName();
		
		dto.setUploadFilePath(uploadFilePath);
		
		//3)임시파일은 제거하고, 파일서버상의 경로를 문자열로 반환
		int row = dao.insert(dto);
		dest.delete();
		return row == 1 ? dto.getUploadFilePath() : null;
	}
}


10)인터페이스생성
public interface UploadDAO {
	@Insert("insert into sftp values (#{uploadFilePath})")
	public int upload(SftpDTO dto);
}

-> 이제 브라우저에서 파일을올리면 리눅스 /var/www/html에 올라간다, db에는 주소가 올라간다

#)브라우저에 디비에들어간 주소를 찍으면 나오게 하기위해서 아래와 같은 작업을 하자
vi /etc/httpd/conf/httpd.conf
LISTEN 1234
wq!

firewall-cmd --add-port=1234/tcp --permanent
firewall-cmd --reload
systemctl enable httpd
systemctl restart httpd


param.put("cond[baseDate

String today = new Sim("yyyy-mm-dd").format(new Date());
String startDate = todayy.substring(0,8)+"01";

return getHttpResponse(urlString) -> 함수에전달
return {
'날짜' : v.baseDate.split(' ')[0],
'1차 접종 인원' : v.total~
}

K7G5hCA%2FRqnmALDK%2F7POZXDGSgTgQFRIcOqpF8HUf9rqLn17QSaJ4Q0Ox732h%2BF%2FgxuyB3bXrdEWApNVwrOtWA%3D%3D


====================================================================================
#)배포
[리눅스 서비스 설치 및 운용]

	기본 포트		서비스 이름	용도
---------------------------------------------------------------
apache	80/tcp		httpd		정적 웹 파일 서비스         //html파일 보여주는 용도
tomcat	8080/tcp	apache-tomcat	스프링 프로젝트 배포	  
oracle	1521/tcp	oracle-xe-18c	Database
ssh	22/tcp		sshd		원격접속/파일전송
---------------------------------------------------------------

root#) javac -version , java -version으로 자바가 리눅스에 깔려있는지 확인
root#) cd /usr/local 
root#) wget https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.75/bin/apache-tomcat-8.5.75.tar.gz --no-check-certificate (인증을 체크하지않겠다)
root#) tar xf apache-tomcat-8.5.75.tar.gz
root#) ln -s apache-tomcat-8.5.75 tomcat
root#) vi /etc/profile.d/tomcat.sh
#!/bin/bash
esc -> :$r! readlink -f /bin/java  -> 엔터  -> 이거를 주석처리하기 (그냥 복사할려고쓴거임)
그다음줄에
JRE_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.302.b08-0.el7_9.x86_64/jre
JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.302.b08-0.el7_9.x86_64
CLASSPATH=$JAVA_HOME/bin
PATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin

저장 후 
export JRE_HOME JAVA_HOME CATALINA_HOME CLASSPATH PATH

source /etc/profile.d/tomcat.sh
echo $CATALINA_HOME
cd $CATALINA_HOME/bin
./startup.sh
-> 그후 윈도우 브라우저에 가상머신 IP치면 톰캣뜬다
//포트가 열려있는지 먼저 확인
netstat -lntup | grep 8080

firewall-cmd --permanent --add-port=80/tcp
firewall-cmd --permanent --add-forward-port=port=80:proto=tcp:toport=8080  //80번으로 들어오면 8080으로 연결해주겠다
firewall-cmd --reload

cd /usr/local/tomcat/webapps
nautilus . &  --> 리눅스 탐색기(노틸러스)가 뜬다

이클립스에서 아무프로젝트(우클릭 -> export -> war -> dest는 바탕화면에 저장 , overwrirting체크) 이거는 현재 war로 압축한다는 뜻이다 -> finish -> 파일이 만들어 진다
윈도우에 있는 파일을 끌어서 놓으면된다. (cd /usr/local/tomcat/webapps )여기 탐색기에다가 -> 해당파일을 더블클릭하면 내용이 나와야한다

드래그드롭이안되면 winscp를 설치
호스트이름 : 리눅스ip

192.168.1.100/exam11A 입력하면 나온다.
exam11A를 ROOT로 바꾸면 알아서 된다. -> 192.168.1.100만입력해도 데이터가 뜬다

vi /etc/systemd/system/tomcat.service
[Unit]
Description=tomcat 8.5
After=network.target syslog.target

[Service]
Type=forking
User=root
Group=root
ExecStart=/usr/local/tomcat/bin/startup.sh
ExecStop=/usr/local/tomcat/bin/shutdown.sh

[Install]
WantedBy=multi-user.target

systemctl daemon-reload
systemctl restart tomcat

cd /usr/local/tomcat/
tail -f $CATALINA_HOME/logs/*      */-> 톰캣의 이벤트가 발생할때마다

===================================================================
ArrayList와 Array의 차이 -> ArrayList는 동적으로 길이가 증가
Array는 primitive type(int,byte,char 등), Object 모두를 담을 수 있지만 ArrayList는 object만 담을수있다.
Array는 lengh를 쓰고, ArrayList는 size()를 쓴다

컨트롤러어드바이스 -> 에러뜨면 여기로 다 처리



